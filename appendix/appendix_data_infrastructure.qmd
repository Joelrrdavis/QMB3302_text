---
title: "Appendix: Data Infrastructure and Databases for AI"
---

# Data Infrastructure and Databases for AI

Modern AI systems depend not only on algorithms and models, but on **the data infrastructure that feeds them**. Databases, storage systems, and data architectures determine:

- how data is collected and stored,  
- how quickly it can be retrieved,  
- what formats it can take,  
- how much data the system can scale to support,  
- and how reliable AI outputs will be.

This appendix provides a conceptual overview of the major database paradigms, architectural choices, and design considerations relevant to AI work.

---

# 1. SQL vs. NoSQL Databases

Databases can be broadly divided into **relational (SQL)** and **non-relational (NoSQL)** systems.

## SQL (Relational Databases)

- Organize data in **tables** with predefined **schemas**.  
- Use the SQL query language for joins, aggregations, and complex analytical queries.  
- Strong support for **ACID transactions**, ensuring reliability and correctness.

**Examples:** PostgreSQL, MySQL, Oracle.

## NoSQL (Non-Relational Databases)

- Use **flexible data models** such as documents (JSON), key–value stores, wide-column tables, or graph structures.  
- Designed for horizontal scaling, large volume, and rapidly changing or semi-structured data.  
- Often rely on **BASE** consistency models (eventual consistency).

**Examples:** MongoDB, Cassandra, DynamoDB, Redis.

### Comparison Table

| Feature | SQL Databases | NoSQL Databases |
|--------|---------------|-----------------|
| Data Model | Relational (tables) | Flexible (document, key-value, graph) |
| Schema | Fixed | Schema-less or dynamic |
| Consistency | Strong (ACID) | Often eventual (BASE) |
| Scaling | Vertical; harder to distribute | Horizontal; distributed by design |
| Query Power | Complex SQL queries | Simple lookups, model-specific querying |
| Use Cases | Transactions, structured analytics | High-volume, unstructured or semi-structured data |

---

# 2. ACID vs. BASE: Transaction Guarantees

## ACID (SQL)

ACID ensures **reliable and correct transactions**.

- **Atomicity:** All or nothing  
- **Consistency:** Maintains valid states  
- **Isolation:** Transactions don’t interfere  
- **Durability:** Once committed, data persists  

## BASE (NoSQL)

BASE prioritizes **scalability and availability**:

- **Basically Available**  
- **Soft State** (state may change over time)  
- **Eventual Consistency** (nodes converge eventually)  

This tradeoff allows large-scale AI systems to ingest data at extremely high speed, but with weaker short-term consistency guarantees.

---

# 3. Vertical vs. Horizontal Scaling

## Vertical Scaling (“Scale Up”)

- Add CPU, RAM, or SSD to a single server.  
- Simpler to manage; strong for transactional workloads.  
- Limited by hardware ceilings.  

**Common with:** SQL databases.

## Horizontal Scaling (“Scale Out”)

- Add more servers (nodes) in a distributed system.  
- Supports massive throughput and storage growth.  
- Requires sharding/partitioning and distributed consistency management.

**Common with:** NoSQL databases.

### Comparison  
| Aspect | Vertical Scaling | Horizontal Scaling |
|--------|------------------|-------------------|
| Approach | Bigger machine | More machines |
| Easy to Implement? | Yes | Harder (distributed systems) |
| Limits | Hardware | Nearly unlimited growth |
| Examples | PostgreSQL | Cassandra, DynamoDB |

---

# 4. In-Memory vs. Disk-Based Databases

## In-Memory Databases

- Store data primarily in **RAM**.  
- Extremely fast; ideal for real-time AI use cases.  
- Volatile unless snapshots/logging enable persistence.

**Examples:** Redis, Memcached, SAP HANA.

## Disk-Based Databases

- Store data on **HDD/SSD**, with caching layers for speed.  
- Support larger datasets with strong persistence.  
- Slower than memory but more reliable for long-term storage.

**Examples:** PostgreSQL, MongoDB.

### Table

| Aspect | In-Memory | Disk-Based |
|--------|-----------|------------|
| Speed | Very fast | Slower but persistent |
| Persistence | Volatile unless logged | Persistent by default |
| Capacity | Limited by RAM | Scales via disk/sharding |
| Use Cases | Caching, sessions, real-time AI | Analytics, transactions, general data storage |

---

# 5. Open-Source vs. Proprietary Databases

## Open-Source

- Free to use and modify  
- Supported by large communities  
- Highly extensible  

**Examples:** PostgreSQL, MySQL, MongoDB

## Proprietary

- Enterprise-grade features  
- Vendor support  
- Integrated tooling for data governance and security  

**Examples:** Oracle, SQL Server, Amazon Aurora

### Comparison Table

| Criteria | Open-Source | Proprietary |
|----------|-------------|-------------|
| Cost | Free | Paid |
| Support | Community-driven | Vendor-backed |
| Extensibility | Very customizable | Controlled by vendor |
| Lock-in | Low | High |

---

# 6. Relational Database Structures for AI

Relational databases remain central in many AI pipelines because:

- They preserve **data integrity**  
- They organize information predictably  
- They support analytical queries and feature generation  

## Example Entity–Relationship Diagram (ERD)

:::: {.columns}
::: {.column width="40%"}
A simplified relational schema for an e-commerce environment:
:::

::: {.column width="60%"}
```{mermaid}
erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--o{ ORDERITEM : includes
    PRODUCT ||--o{ ORDERITEM : listed_in
```
:::
::::

## Primary and Foreign Keys

Relational databases use **primary keys (PK)** to uniquely identify each record in a table, and **foreign keys (FK)** to establish relationships between tables. These relationships enable joins that enrich feature engineering and support downstream analytics.

| **Table**    | **Primary Key (PK)**         | **Foreign Keys (FK)**            |
|--------------|-------------------------------|----------------------------------|
| **CUSTOMER** | `customer_id`                 | —                                |
| **ORDER**    | `order_id`                    | `customer_id`                    |
| **PRODUCT**  | `product_id`                  | —                                |
| **ORDERITEM**| (`order_id`, `product_id`)    | `order_id`, `product_id`         |

These relationships enable integrated datasets where customer attributes, product attributes, and transactional details can be combined for analytics, feature engineering, and modeling.

---

## How Database Choice Shapes AI Systems

Database choices directly influence the reliability, speed, and scalability of AI systems. Key dimensions include:

### **Performance**
- Slow reads or writes → delays in model training  
- Bottlenecks in feature retrieval → slower real-time predictions  

### **Scalability**
- AI systems accumulate **massive datasets**
- NoSQL architectures often become necessary for high-volume logs, telemetry, or clickstream data  

### **Consistency Requirements**
- **High-stakes domains** (e.g., fraud detection, finance) require ACID guarantees  
- **Recommendation engines** and other high-throughput AI applications can tolerate eventual consistency  

### **Data Structure Variety**
- **SQL**: ideal for structured, tabular data  
- **NoSQL**: more natural for JSON documents, event logs, sensor streams, and heterogeneous data  

### **Latency and Throughput**
- **Real-time inference**: best supported by in-memory stores or fast NoSQL systems  
- **Batch training**: disk-based analytical stores suffice and can handle larger volumes  

---

## Real-Time vs. Batch Data Workflows in AI

### **Real-Time AI**
- Continuous ingestion of events  
- Low-latency feature retrieval and decision-making  
- Powers applications like:  
  - live recommendation engines  
  - anomaly detection  
  - streaming fraud detection  
  - chatbots and conversational agents  

### **Batch AI**
- Periodic, scheduled data ingestion  
- Used for:  
  - nightly or weekly model retraining  
  - offline scoring  
  - long-term historical analysis  

Most production AI systems use **both** approaches:  
real-time for immediate decisions, and batch for maintaining or improving the models.

---

## Summary

This appendix outlines core concepts in data infrastructure that support AI systems. Key takeaways include:

- **No single database is “best”** for all AI applications — choices should reflect workload, data structures, and consistency needs.  
- **SQL databases** excel for structured, transactional, strongly consistent data.  
- **NoSQL databases** excel for scale, flexibility, and high-volume unstructured or semi-structured data.  
- **Scaling strategy** matters: vertical scaling increases hardware capacity on one machine, while horizontal scaling distributes data across many nodes.  
- **In-memory vs. disk-based** architectures determine latency, throughput, and persistence strategies.  
- **Data architecture decisions directly impact model quality**, model-training speed, feature delivery, and operational reliability.

AI models depend critically on the systems beneath them.  
Understanding database infrastructure is therefore an essential component of understanding modern AI systems.

