<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>AI Systems: Data, Models, and Logic – Foundations of Analytics &amp; AI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="access.theme.scss">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Foundations of Analytics &amp; AI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-textbook" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Textbook</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-textbook">    
        <li>
    <a class="dropdown-item" href="../textbook_src/ch1_foundations_analytics_ai_split.html">
 <span class="dropdown-text">Ch 1. What Is Analytics &amp; AI?</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch2_ai_systems_data_models_logic.html">
 <span class="dropdown-text">Ch 2. AI Systems: Data, Models, Logic</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch3_data_pipelines_decision_frameworks.html">
 <span class="dropdown-text">Ch 3. Data Pipelines &amp; Decision Frameworks</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch4_terminal_paths_envs.html">
 <span class="dropdown-text">Ch 4. Python Execution Foundations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch5_python_foundations_data_control_functions.html">
 <span class="dropdown-text">Ch 5. Python Basics: Data, Control, Functions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch6_working_with_tabular_data_pandas.html">
 <span class="dropdown-text">Ch 6. Working with Tabular Data in Pandas</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch7_json_apis_data_access.html">
 <span class="dropdown-text">Ch 7. JSON and APIs for Data Access</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch8_simulation_synthetic_data.html">
 <span class="dropdown-text">Ch 8. Simulation and Synthetic Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch9_visualization_from_data_to_insight.html">
 <span class="dropdown-text">Ch 9. Visualization: From Data to Insight</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-guides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Guides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-guides">    
        <li>
    <a class="dropdown-item" href="../guides/terminal_powershell_basics.html">
 <span class="dropdown-text">Terminal and PowerShell Basics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/setup_python_uv_vscode.html">
 <span class="dropdown-text">Install Python, uv, VS Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/using_colab.html">
 <span class="dropdown-text">Using Colab</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/vscode_update_stability.html">
 <span class="dropdown-text">Locking VS Code Updates (Optional)</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#data-models-and-logic-core-components-of-ai-systems" id="toc-data-models-and-logic-core-components-of-ai-systems" class="nav-link active" data-scroll-target="#data-models-and-logic-core-components-of-ai-systems">Data, Models, and Logic: Core Components of AI Systems</a>
  <ul class="collapse">
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#models" id="toc-models" class="nav-link" data-scroll-target="#models">Models</a></li>
  <li><a href="#logic" id="toc-logic" class="nav-link" data-scroll-target="#logic">Logic</a></li>
  <li><a href="#where-systems-fail-data-model-logic-layers" id="toc-where-systems-fail-data-model-logic-layers" class="nav-link" data-scroll-target="#where-systems-fail-data-model-logic-layers">Where Systems Fail (Data, Model, Logic Layers)</a></li>
  </ul></li>
  <li><a href="#ai-paradigms-overview" id="toc-ai-paradigms-overview" class="nav-link" data-scroll-target="#ai-paradigms-overview">AI Paradigms Overview</a>
  <ul class="collapse">
  <li><a href="#symbolic-ai" id="toc-symbolic-ai" class="nav-link" data-scroll-target="#symbolic-ai">Symbolic AI</a></li>
  <li><a href="#statistical-and-machine-learning" id="toc-statistical-and-machine-learning" class="nav-link" data-scroll-target="#statistical-and-machine-learning">Statistical and Machine Learning</a></li>
  <li><a href="#neural-and-deep-learning" id="toc-neural-and-deep-learning" class="nav-link" data-scroll-target="#neural-and-deep-learning">Neural and Deep Learning</a></li>
  <li><a href="#hybrid-systems-in-practice" id="toc-hybrid-systems-in-practice" class="nav-link" data-scroll-target="#hybrid-systems-in-practice">Hybrid Systems in Practice</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AI Systems: Data, Models, and Logic</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="data-models-and-logic-core-components-of-ai-systems" class="level2">
<h2 class="anchored" data-anchor-id="data-models-and-logic-core-components-of-ai-systems">Data, Models, and Logic: Core Components of AI Systems</h2>
<figure class="figure">
<img src="../assets/images/1_core_system.svg" alt="Core AI system diagram showing a left-to-right flow: Data feeds into Model, Model feeds into Logic, and Logic triggers Action. Arrows indicate sequential flow from inputs to decisions." class="figure-img">
<figcaption>
An AI system is best understood as the interaction of data, a model, and decision logic—rather than as a model alone.
</figcaption>
</figure>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>Data forms the foundation of all analytics and AI systems. Regardless of how sophisticated a model or decision framework may be, the system’s behavior is shaped by the data it has available. Understanding what data represents, how it is generated, and how it enters a system is a critical step toward understanding how AI systems operate.</p>
<p>Data takes many forms, such as transaction records, sensor readings, text documents, images, user interactions, or system logs. These sources differ in structure and complexity, but all capture past events or states that can be analyzed, modeled, and acted upon.</p>
<p>Data serves two very critical functions within AI systems. First, it is used to <strong>train models</strong>. Historical data provides the needed examples from which AI models learn patterns, relationships, or representations. The coverage and quality of this data directly influence what a model can learn and how well it generalizes <em>beyond</em> its training examples. Second, data is used during <strong>system operation</strong>, when new observations are provided as input to a trained model in order to generate predictions, classifications, or scores. The key thing to remember here is that errors, shifts, or inconsistencies in <em>either</em> training data <em>or</em> operational data can degrade system performance.</p>
<p>For the most part, data is not a complete or neutral representation of reality. Data always reflects the processes through which it was collected. These include factors such as organizational priorities, technical constraints, and human choices. Some phenomena are easier to observe and record than others, some groups or behaviors are overrepresented, and some variables serve only as indirect proxies for what is actually of interest. As a result, data commonly contains noise, omissions, and systematic issues that need to be addressed.</p>
<p>From a systems perspective, data does not simply exist, ready to be used by whatever model is in place; it is <strong>acquired and prepared</strong>, in a process often referred to as a pipeline. These pipelines involve decisions about what to collect, how frequently to collect it, how it is stored, and how it is cleaned or transformed before use. Choices made at this stage can have consequences that propagate throughout the system. Often in surprising ways.</p>
<p>Practical analysis of AI systems begins with careful attention to the data being collected. Asking where data comes from, what it represents, and what it leaves out is often the most, and sometimes the only, reliable way to understand system behavior, anticipate limitations, and diagnose failures.</p>
<p>A defining challenge for artificial intelligence systems is operating under uncertainty. Data is often incomplete, noisy, delayed, or sometimes just plain wrong. Models can only approximate real-world processes. AI models don’t try to eliminate uncertainty; they’re designed to manage and act despite it, using probabilistic reasoning, learned patterns, and decision logic to operate in the imperfect environments they are placed in.</p>
</section>
<section id="models" class="level3">
<h3 class="anchored" data-anchor-id="models">Models</h3>
<p>A <strong>model</strong> is a formal representation of a relationship between inputs and outputs. In analytics and AI systems, models are used to map the observed data (inputs) to predictions, classifications, scores, or other quantities (outputs) that support decision-making. Models provide a structured way to generalize from past observations to new situations.</p>
<p>Data records what has already happened. The keyword to remember there is “already”. <strong>All data is from the past.</strong> We can’t collect data on the future. Models, on the other hand, encode assumptions about <strong>how the world works</strong>. The model’s assumptions might be explicit. Obvious assumptions that are easily interpretable, as in a linear equation that specifies how inputs specifically combine to produce some output. Alternatively, the model might be more implicit, as in a deep learning model that learns internal representations through training on large datasets.</p>
<p>In supervised learning models, data (the model’s input) is used to adjust a model’s parameters so that its outputs align as closely as possible with the observed outcomes. This <strong>training proceess</strong> allows the model to capture the relationships and patterns in the data. Of course this also ties the model’s behavior to the quality and scope of the data it was trained on. A model cannot reliably learn patterns that are absent, rare, or systematically distorted in the training data.</p>
<p>Once trained, a model is given *new inputs and uses the representation that is learned in training to generate an output. These outputs are often <strong>probabilistic</strong> rather than deterministic; the model can’t “know” that the process it followed to map the input data and adjust its parameters is accurate or without loss. Instead of producing a single “correct” answer, a model may estimate the likelihood of different outcomes or assign scores that reflect a relative confidence in a range of outputs. This probabilistic nature is a strength as it allows models to operate under a high level of uncertainty.</p>
<p>Talking about models this way is perhaps a little dangerous. Models are not inherently intelligent or autonomous. They do not understand context, intent, or consequences in a human sense. Instead, they apply learned patterns mechanically, based on the structure learned in training. This allows them to perform exceptionally well within familiar contexts, constraints, boundaries, and conditions, while behaving unpredictably when those conditions change.</p>
<p>Models can recognize patterns, make estimates, and scale decisions, but they do so within the boundaries defined by the data available, training procedures, and design choices of the model’s architect.</p>
</section>
<section id="logic" class="level3">
<h3 class="anchored" data-anchor-id="logic">Logic</h3>
<p>Data, and the models that result from training, are often the most visible and perhaps “coolest” components of AI systems. But <strong>logic</strong> is what ultimately connects model outputs to real-world actions. Logic defines how predictions, scores, or classifications are interpreted and how they are translated into actions.</p>
<p>Logic is the <strong>rules, thresholds, constraints, and objectives</strong> that govern a system’s behavior. These elements specify what should happen when a model produces a given output. In a system designed to detect credit card fraud, a model may provide a probability score that fraud has occurred. This score might then be compared against some threshold, the level at which the business would like to take Action on the prediction, and an alert triggered. These thresholds are not inherent to the model; the model just outputs the prediction. These thresholds are design choices that reflect priorities, trade-offs, and risk tolerance.</p>
<p>Logic also encodes <strong>business or organizational constraints</strong>. All businesses and organizations face at least some constraints, such as resource limitations, regulatory requirements, fairness considerations, or cost structures. A model might identify many high-risk cases, but logic determines how many can realistically be acted upon, which cases are prioritized, and which actions are permissible. As a result, logic often mediates between what a model suggests and what an organization can or should do.</p>
<p>Logic can be implemented in various ways. In some systems, it takes the form of explicit rules written by humans, “when we see x, we do y. In others, it can be nuanced, the logic embedded within optimization routines, data collection policies, or decision frameworks. Even when decisions by a system appear automated, they are often controlled by the logic layered on through past human judgments about acceptable or optimal outcomes.</p>
<p><strong>Models produce outputs, but logic determines actions</strong>.</p>
</section>
<section id="where-systems-fail-data-model-logic-layers" class="level3">
<h3 class="anchored" data-anchor-id="where-systems-fail-data-model-logic-layers">Where Systems Fail (Data, Model, Logic Layers)</h3>
<p>Failures in analytics and AI systems tend to come from breakdowns at one or more layers of the system: <strong>data</strong>, <strong>models</strong>, or <strong>logic</strong>. Understanding these layers and the interactions between them provides a structured way to diagnose system results and understand why a system produces a sub-optimal outcome.</p>
<p>Missing values, measurement errors, outdated records, or shifts in underlying patterns over time can cause failures in this <strong>data layer</strong>. Because models base their learning here, weaknesses or problems at this layer often propagate forward, limiting what the system can achieve, regardless of how sophisticated the model is</p>
<p>Failures at the <strong>model layer</strong> arise when the model itself is poorly matched to the problem, task, or data available. This may involve using overly simplistic models that fail to capture complex but important relationships. Conservatively, this is also sometimes the use of overly complex models that overfit historical patterns. Even well-designed models can fail when deployed in contexts that differ meaningfully from those seen during training.</p>
<p>Poorly chosen or arbitrary thresholds, rigid rules that do not adapt to changing conditions, or decision criteria that prioritize the wrong objectives can all lead to failures inte *logic layer**. In these cases, a model may be producing reasonable outputs, but the surrounding logic causes undesirable actions or missed opportunities.</p>
<p>These layers are closely intertwined. High data quality and a strong model can’t save a system with seriously flawed logic. Likewise, careful logic cannot compensate for fundamentally uninformative or skewed data.</p>
<p>Considering failures throughout these different layers, allows for more precide intervention when models go wrong. Rather than asking whether an AI system “works” or “does not work,” it becomes possible to ask <em>where</em> it is breaking down and <em>why</em>.</p>
</section>
</section>
<section id="ai-paradigms-overview" class="level2">
<h2 class="anchored" data-anchor-id="ai-paradigms-overview">AI Paradigms Overview</h2>
<figure class="figure">
<img src="../assets/images/1_qmb_nested_ai.svg" alt="Conceptual diagram showing AI as the broad area, with machine learning as a subset and deep learning as a further subset." class="figure-img">
<figcaption>
A useful shorthand: AI includes many approaches, with machine learning and deep learning representing increasingly specialized subsets.
</figcaption>
</figure>
<section id="symbolic-ai" class="level3">
<h3 class="anchored" data-anchor-id="symbolic-ai">Symbolic AI</h3>
<p>Symbolic systems rely on <strong>explicit representations of knowledge</strong> and <strong>rule-based reasoning</strong> to perform tasks. Contrast that with the types of systems we have been discussing so far, which use pattern recognition from data. These systems operate by manipulating inputs (words, categories, etc) according to predefined rules.</p>
<p>The main idea in this approach is that intelligent behavior can be produced by encoding expert knowledge directly, as a series of rules and decision points, into a system. This often takes the form of <em>if–then</em> rules. For example, a symbolic system might contain rules such as: <em>if a customer is late on payment and has missed multiple deadlines, then flag the account for review</em>. Each rule reflects a human and/or expert judgment that has been translated into formal logic.</p>
<p>Symbolic AI systems tend to be <strong>transparent and interpretable</strong>. Because their reasoning process is explicitly defined, it is usually possible to trace back to how a particular outcome was reached by the system. This makes these symbolic approaches attractive, and sometimes even required, in domains where explanations, compliance, or auditability are critical. They perform best in environments where the rules are stable, the problem space and scope are well understood, and rarely change.</p>
<p>There are some obvious limitations. Writing and maintaining rules is labor-intensive, complex, and such systems almost always struggle to scale as complexity increases. They also perform poorly in settings characterized by ambiguity, noise, or high variability (change).</p>
<p>While symbolic AI is no longer the dominant approach/paradigm, it is still an important conceptual foundation. Many modern AI systems rely on symbolic components for managing constraints, validation, and control.</p>
</section>
<section id="statistical-and-machine-learning" class="level3">
<h3 class="anchored" data-anchor-id="statistical-and-machine-learning">Statistical and Machine Learning</h3>
<p>Statistical and machine learning approaches to AI differ from symbolic systems in a fundamental way: rather than relying on explicitly programmed rules, they <strong>learn patterns from data</strong>. These approaches use historical observations to infer relationships between inputs and outputs, allowing systems to generalize to new, unseen cases without being told exactly how to respond in every situation.</p>
<p>At the heart of machine learning is the idea that patterns (sometimes referred to as in data can be captured through mathematical models whose parameters are estimated from examples. During training, a model is exposed to data and adjusted so that its predictions align with observed outcomes as closely as possible. This process allows the system to adapt to complex patterns that would be difficult to specify manually using rules alone.</p>
<p>Machine learning methods are often categorized based on the type of feedback available during training. In <strong>supervised learning</strong>, the model is trained using labeled examples. Each case (row or example) has a number of inputs, and then a labeled output. So the model knows the correct output in advance, for a large set of training data. In <strong>unsupervised learning</strong>, the model works with unlabeled data to identify structure. There is a number of cases (rows or examples), but there is no “known” outcome of interest. These models are often used to identify clusters or latent patterns, without predefined outcomes. Both approaches are widely used in analytics and AI systems.</p>
<p>Compared to symbolic AI, statistical and machine learning systems are, for the most part, more flexible and scalable. Think of the fundamental differences: for every pattern in the data, a symbolic AI system needs to write a rule. Often, a human expert has to help with that rule. This is incredibly costly in terms of time and effort, and is brittle when new data is introduced. A machine learning system can build a model on data, and then build a model again when new data is introduced. These approaches perform well in situations with large volumes of data and are more adaptable when there are subtle patterns or relationships in the data. However, this flexibility comes with trade-offs. Learned models may be less transparent; you can’t simply follow the system’s logic in some of them as you would in Symbolic AI systems. In addition, they are obviously very sensitive to the data and the decisions made about which data to include/exclude. The data used is almost always a proxy for the data we would like to have.</p>
<p>Statistical and machine learning approaches do not eliminate the need for human judgment. There are performance consequences to choices about data, features, and model evaluation/metrics. One way to think about Machine learning is that it shifts the burden of specification from rule-writing to <strong>data curation and model design</strong>. Expertise is still needed in the system, just applied within a different area.</p>
<p>This paradigm has become central to modern analytics and AI, forming the basis for many applications encountered in practice. It also provides the foundation for more advanced approaches, such as neural and deep learning.</p>
</section>
<section id="neural-and-deep-learning" class="level3">
<h3 class="anchored" data-anchor-id="neural-and-deep-learning">Neural and Deep Learning</h3>
<figure class="figure">
<img src="../assets/images/deep_neural_network_structure_input.svg" alt="Neural Networks are comprised of inputs, hidden layers, and output layers. The image shows a series of neurons, which look like nodes or circles, that are connected with lines, called synapses. " class="figure-img">
<figcaption>
Neural Networks are comprised of inputs, hidden layers, and output layers.
</figcaption>
</figure>
<p>Neural and deep learning approaches extend the main idea of statistical machine learning by focusing on <strong>learning representations</strong> directly from data. These models use layered computational structures, <em>neural networks</em>, to transform raw inputs into increasingly abstract representations.</p>
<p>The key idea behind neural networks is inspired by, but not equivalent to, biological neurons. A neural network is composed of interconnected units that apply weighted combinations of inputs, followed by nonlinear transformations. If this sounds complicated it is. Later chapters will dig into the concept in more depth. But the essential idea is that the layered structure allows these models to excel in tasks such as image recognition, speech processing, and natural language understanding, where relationships are difficult to specify explicitly.</p>
<p>One defining characteristic of deep learning is its ability to operate on <strong>unstructured or semi-structured data</strong>, including images, audio, and text. In these domains, traditional statistical models often require extensive feature engineering. Deep learning models, by contrast, can learn relevant representations automatically from large volumes of data, reducing the need for manual (human) specification of features. One way to think of this, not exactly correct but probably good enough for beginners, is that these systems are like automated versions of symbolic AI. Their computing power allows for thousands, millions of rules to be created to extract even very faint patterns.</p>
<p>The ability to model complex relationships comes with a trade-off. Neural and deep learning models are <strong>data-intensive and computationally demanding</strong>. Training them often requires large datasets, which can be expensive to obtain, store, and manage. They also often need specialized and expensive computer hardware. These approaches are also less interpretable than simpler models. The very nature of the complex modeling process makes it more difficult to explain <em>why</em> a particular output was produced.</p>
</section>
<section id="hybrid-systems-in-practice" class="level3">
<h3 class="anchored" data-anchor-id="hybrid-systems-in-practice">Hybrid Systems in Practice</h3>
<figure class="figure">
<img src="../assets/images/1_hybrid_paradigm.svg" alt="Hybrid AI paradigm diagram showing learned components, rule-based components, and human oversight combining into a decision layer." class="figure-img">
<figcaption>
Most real-world AI systems blend machine learning, rules, and human oversight rather than relying on a single paradigm.
</figcaption>
</figure>
<p>AI is usually deployed as a<strong>hybrid system</strong>, combining features of symbolic reasoning systems, machine learning approaches, and neural networks. Most systems don’t rely on a single paradigm. Each approach contributes different strengths, and hybrid designs allow systems to balance performance, interpretability, and control.</p>
<p>Imagine a deep learning system, designed primarily for object recognition. This system might be used to search for specific objects within an image or a video. The output of that vision system might be fed into a rule-based layer, which might determine if the output meets a threshold for taking or triggering some specific action. That Action might be fed into a third system in that chain, and so on. Systems that focus on <strong>perception and prediction</strong> are frequently rated with <strong>symbolic rule-based systems</strong> to map operational constraints.</p>
<p>Hybrid systems also help address the practical limitations of individual approaches. Machine learning models can adapt to data and capture subtle patterns, but they may behave unpredictably outside familiar conditions. Symbolic logic imposes guardrails, prevents certain actions, or requires human review under specified circumstances. Statistical models can provide calibrated probabilities that support decision thresholds and prioritization. Together, these components form systems that are more robust than any single approach alone.</p>
<p>Think of the AI system almost everyone has encountered: recommendation systems. These combine user data such as past purchases, preferences, and page views. When the model is run, a machine learning only model would show the items to the user with the highest probability of purchase, or the highest possible value. A more complex system might combine a symbolic approach and use a logic function to validate that the item is in stock and available, and that the recommendation does not violate any company rules or legal restrictions.</p>
<p>Intelligence, or what we may take for intelligence, in computer systems is in practice <strong>distributed across different system components</strong>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>