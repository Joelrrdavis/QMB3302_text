<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Working with Tabular Data in Pandas – Foundations of Analytics &amp; AI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="access.theme.scss">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Foundations of Analytics &amp; AI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-textbook" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Textbook</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-textbook">    
        <li>
    <a class="dropdown-item" href="../textbook_src/ch1_foundations_analytics_ai_split.html">
 <span class="dropdown-text">Ch 1. What Is Analytics &amp; AI?</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch2_ai_systems_data_models_logic.html">
 <span class="dropdown-text">Ch 2. AI Systems: Data, Models, Logic</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch3_data_pipelines_decision_frameworks.html">
 <span class="dropdown-text">Ch 3. Data Pipelines &amp; Decision Frameworks</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch4_terminal_paths_envs.html">
 <span class="dropdown-text">Ch 4. Python Execution Foundations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch5_python_foundations_data_control_functions.html">
 <span class="dropdown-text">Ch 5. Python Basics: Data, Control, Functions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch6_working_with_tabular_data_pandas.html">
 <span class="dropdown-text">Ch 6. Working with Tabular Data in Pandas</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch7_json_apis_data_access.html">
 <span class="dropdown-text">Ch 7. JSON and APIs for Data Access</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch8_simulation_synthetic_data.html">
 <span class="dropdown-text">Ch 8. Simulation and Synthetic Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch9_visualization_from_data_to_insight.html">
 <span class="dropdown-text">Ch 9. Visualization: From Data to Insight</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-guides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Guides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-guides">    
        <li>
    <a class="dropdown-item" href="../guides/terminal_powershell_basics.html">
 <span class="dropdown-text">Terminal and PowerShell Basics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/setup_python_uv_vscode.html">
 <span class="dropdown-text">Install Python, uv, VS Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/using_colab.html">
 <span class="dropdown-text">Using Colab</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/vscode_update_stability.html">
 <span class="dropdown-text">Locking VS Code Updates (Optional)</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#data-concepts-what-is-a-dataset" id="toc-data-concepts-what-is-a-dataset" class="nav-link" data-scroll-target="#data-concepts-what-is-a-dataset">Data Concepts: What Is a Dataset?</a>
  <ul class="collapse">
  <li><a href="#what-a-dataset-represents" id="toc-what-a-dataset-represents" class="nav-link" data-scroll-target="#what-a-dataset-represents">What a dataset represents</a></li>
  <li><a href="#schema-and-structure" id="toc-schema-and-structure" class="nav-link" data-scroll-target="#schema-and-structure">Schema and structure</a></li>
  <li><a href="#structured-vs-unstructured-data" id="toc-structured-vs-unstructured-data" class="nav-link" data-scroll-target="#structured-vs-unstructured-data">Structured vs unstructured data</a></li>
  </ul></li>
  <li><a href="#getting-started-with-pandas" id="toc-getting-started-with-pandas" class="nav-link" data-scroll-target="#getting-started-with-pandas">Getting Started with Pandas</a>
  <ul class="collapse">
  <li><a href="#what-pandas-is" id="toc-what-pandas-is" class="nav-link" data-scroll-target="#what-pandas-is">What Pandas is</a></li>
  <li><a href="#dataframes-and-series" id="toc-dataframes-and-series" class="nav-link" data-scroll-target="#dataframes-and-series">DataFrames and Series</a></li>
  </ul></li>
  <li><a href="#files-and-paths-in-data-workflows" id="toc-files-and-paths-in-data-workflows" class="nav-link" data-scroll-target="#files-and-paths-in-data-workflows">Files and Paths in Data Workflows</a>
  <ul class="collapse">
  <li><a href="#why-file-paths-matter-for-data" id="toc-why-file-paths-matter-for-data" class="nav-link" data-scroll-target="#why-file-paths-matter-for-data">Why file paths matter for data</a></li>
  <li><a href="#relative-vs-absolute-paths-revisited" id="toc-relative-vs-absolute-paths-revisited" class="nav-link" data-scroll-target="#relative-vs-absolute-paths-revisited">Relative vs absolute paths (revisited)</a></li>
  <li><a href="#common-file-path-errors-also-revisted" id="toc-common-file-path-errors-also-revisted" class="nav-link" data-scroll-target="#common-file-path-errors-also-revisted">Common file path errors (also revisted)</a></li>
  </ul></li>
  <li><a href="#loading-data-from-csv-files" id="toc-loading-data-from-csv-files" class="nav-link" data-scroll-target="#loading-data-from-csv-files">Loading Data from CSV Files</a>
  <ul class="collapse">
  <li><a href="#csv-files-as-datasets" id="toc-csv-files-as-datasets" class="nav-link" data-scroll-target="#csv-files-as-datasets">CSV files as datasets</a></li>
  <li><a href="#reading-csv-files-with-pandas" id="toc-reading-csv-files-with-pandas" class="nav-link" data-scroll-target="#reading-csv-files-with-pandas">Reading CSV files with Pandas</a></li>
  <li><a href="#verifying-successful-data-loading" id="toc-verifying-successful-data-loading" class="nav-link" data-scroll-target="#verifying-successful-data-loading">Verifying successful data loading</a></li>
  </ul></li>
  <li><a href="#data-cleaning-and-exploration" id="toc-data-cleaning-and-exploration" class="nav-link" data-scroll-target="#data-cleaning-and-exploration">Data Cleaning and Exploration</a>
  <ul class="collapse">
  <li><a href="#inspecting-data-structure" id="toc-inspecting-data-structure" class="nav-link" data-scroll-target="#inspecting-data-structure">Inspecting data structure</a></li>
  <li><a href="#descriptive-summaries" id="toc-descriptive-summaries" class="nav-link" data-scroll-target="#descriptive-summaries">Descriptive summaries</a></li>
  </ul></li>
  <li><a href="#handling-missing-values" id="toc-handling-missing-values" class="nav-link" data-scroll-target="#handling-missing-values">Handling Missing Values</a>
  <ul class="collapse">
  <li><a href="#what-missing-data-represents" id="toc-what-missing-data-represents" class="nav-link" data-scroll-target="#what-missing-data-represents">What missing data represents</a></li>
  <li><a href="#detecting-missing-values" id="toc-detecting-missing-values" class="nav-link" data-scroll-target="#detecting-missing-values">Detecting missing values</a></li>
  <li><a href="#simple-strategies-for-handling-missing-data" id="toc-simple-strategies-for-handling-missing-data" class="nav-link" data-scroll-target="#simple-strategies-for-handling-missing-data">Simple strategies for handling missing data</a></li>
  </ul></li>
  <li><a href="#renaming-and-dropping-columns" id="toc-renaming-and-dropping-columns" class="nav-link" data-scroll-target="#renaming-and-dropping-columns">Renaming and Dropping Columns</a>
  <ul class="collapse">
  <li><a href="#why-column-names-matter" id="toc-why-column-names-matter" class="nav-link" data-scroll-target="#why-column-names-matter">Why column names matter</a></li>
  <li><a href="#renaming-columns" id="toc-renaming-columns" class="nav-link" data-scroll-target="#renaming-columns">Renaming columns</a></li>
  <li><a href="#dropping-columns" id="toc-dropping-columns" class="nav-link" data-scroll-target="#dropping-columns">Dropping columns</a></li>
  </ul></li>
  <li><a href="#data-transformation-filtering-and-selecting-data" id="toc-data-transformation-filtering-and-selecting-data" class="nav-link" data-scroll-target="#data-transformation-filtering-and-selecting-data">Data Transformation: Filtering and Selecting Data</a>
  <ul class="collapse">
  <li><a href="#selecting-columns" id="toc-selecting-columns" class="nav-link" data-scroll-target="#selecting-columns">Selecting columns</a></li>
  <li><a href="#filtering-rows-with-conditions" id="toc-filtering-rows-with-conditions" class="nav-link" data-scroll-target="#filtering-rows-with-conditions">Filtering rows with conditions</a></li>
  <li><a href="#using-.loc-and-.iloc" id="toc-using-.loc-and-.iloc" class="nav-link" data-scroll-target="#using-.loc-and-.iloc">Using .loc and .iloc</a></li>
  </ul></li>
  <li><a href="#descriptive-statistics-with-pandas" id="toc-descriptive-statistics-with-pandas" class="nav-link" data-scroll-target="#descriptive-statistics-with-pandas">Descriptive Statistics with Pandas</a>
  <ul class="collapse">
  <li><a href="#why-summarization-matters" id="toc-why-summarization-matters" class="nav-link" data-scroll-target="#why-summarization-matters">Why summarization matters</a></li>
  <li><a href="#common-summary-statistics" id="toc-common-summary-statistics" class="nav-link" data-scroll-target="#common-summary-statistics">Common summary statistics</a></li>
  <li><a href="#group-level-summaries-conceptual-preview" id="toc-group-level-summaries-conceptual-preview" class="nav-link" data-scroll-target="#group-level-summaries-conceptual-preview">Group-level summaries (conceptual preview)</a></li>
  </ul></li>
  <li><a href="#chapter-summary" id="toc-chapter-summary" class="nav-link" data-scroll-target="#chapter-summary">Chapter Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Working with Tabular Data in Pandas</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<hr>
</section>
<section id="data-concepts-what-is-a-dataset" class="level2">
<h2 class="anchored" data-anchor-id="data-concepts-what-is-a-dataset">Data Concepts: What Is a Dataset?</h2>
<p>Before working with tools like Pandas or loading files into Python, it is important to clarify what we mean by a <em>dataset</em>. In analytics and AI, datasets are not just collections of numbers or text—they are structured representations of observations about the world. How data is organized determines what kinds of questions can be asked and what kinds of analysis are possible.</p>
<section id="what-a-dataset-represents" class="level3">
<h3 class="anchored" data-anchor-id="what-a-dataset-represents">What a dataset represents</h3>
<p>A <strong>dataset</strong> is a structured collection of observations. Each observation represents a single instance, case, or entity, and each observation is described using a consistent set of attributes.</p>
<p>In most analytical contexts, datasets are organized in a <strong>tabular form</strong>:<br>
- <strong>Rows</strong> represent individual observations or records.<br>
- <strong>Columns</strong> represent variables or attributes measured for each observation.</p>
<p>This is probably a familiar structure. Most excel worksheets are organized in the same way. For example, a dataset of students might contain one row per student and columns for attributes such as major, exam score, or graduation year. A dataset of transactions might contain one row per transaction and columns describing amount, date, or location.</p>
<p>This structure allows datasets to be treated as inputs to analytics and AI systems. Models, summaries, and visualizations all assume that data is organized in a consistent way, where each row means the same thing and each column has a defined interpretation.</p>
<p>Conceptually, a dataset answers the question:<br>
<em>What observations do we have, and what do we know about each one?</em></p>
</section>
<section id="schema-and-structure" class="level3">
<h3 class="anchored" data-anchor-id="schema-and-structure">Schema and structure</h3>
<p>A dataset is more than just values arranged in rows and columns. It also has a <strong>schema</strong>, which defines the structure and meaning of the data.</p>
<p>A schema specifies:<br>
- what columns exist,<br>
- what each column represents,<br>
- and what type of data each column contains.</p>
<p>For example, a column might represent numeric values, categorical labels, dates, or text. These distinctions matter because different operations are valid for different types of data. Numeric columns can be averaged or summed, while text columns cannot. Boolean columns encode yes/no logic, while categorical columns group observations into meaningful categories.</p>
<p>Structure is what allows computers to process data reliably. When the structure is clear and consistent, programs can apply the same operations across all rows without ambiguity. When structure is unclear or inconsistent, errors become more likely and results become harder to interpret.</p>
<p>In analytics and AI workflows, much of the effort is spent not on modeling itself, but on <strong>ensuring that data conforms to an expected schema</strong>.</p>
</section>
<section id="structured-vs-unstructured-data" class="level3">
<h3 class="anchored" data-anchor-id="structured-vs-unstructured-data">Structured vs unstructured data</h3>
<p>Not all data is organized in neat tables. It is useful to distinguish between <strong>structured</strong> and <strong>unstructured</strong> data.</p>
<p><strong>Structured data</strong> follows a consistent format, with clearly defined rows, columns, and data types. Examples include spreadsheets, CSV files, and database tables. This kind of data is well suited for tools like Pandas, which are designed to operate on tabular structures.</p>
<p><strong>Unstructured data</strong>, by contrast, does not naturally fit into a fixed table. Examples include free-form text, images, audio recordings, and video. While these data types are extremely important in modern AI systems, they require different representations and tools before they can be analyzed in the same way as structured data.</p>
<p>Many, but not all, AI workflows begin by transforming unstructured data into structured form. For example, text may be converted into counts, embeddings, or labels; images may be converted into feature vectors. Once data is structured, it can be stored in datasets and processed using familiar analytical tools.</p>
<hr>
</section>
</section>
<section id="getting-started-with-pandas" class="level2">
<h2 class="anchored" data-anchor-id="getting-started-with-pandas">Getting Started with Pandas</h2>
<p>As datasets grow in size and complexity, basic Python data structures such as lists and dictionaries begin to show their limitations. While these structures are essential building blocks, they are not designed to efficiently represent or manipulate large, tabular datasets. Pandas was created to fill this gap.</p>
<section id="what-pandas-is" class="level3">
<h3 class="anchored" data-anchor-id="what-pandas-is">What Pandas is</h3>
<p>Lists and dictionaries are flexible and powerful, but they are not well suited for representing tables of data. Lists organize values by position, and dictionaries organize values by keys, but neither naturally represents a dataset with many rows and many columns where operations need to be applied consistently across variables.</p>
<p>For example, storing each column of a dataset as a separate list quickly becomes difficult to manage. Ensuring that all lists stay aligned, handling missing values, and performing column-wise operations requires substantial manual effort and careful bookkeeping.</p>
<p>Pandas is a <strong>data analysis library</strong> designed specifically to address these challenges. It provides data structures and functions that make it easier to load, inspect, clean, transform, and summarize structured data. Rather than working with individual values or small collections, Pandas allows programs to operate directly on entire datasets.</p>
<p>At the center of Pandas is the <strong>DataFrame</strong>, which represents a dataset as a table with labeled columns and indexed rows. This abstraction closely mirrors how analysts and decision-makers think about data, making code more readable and reducing the cognitive gap between analysis intent and implementation.</p>
</section>
<section id="dataframes-and-series" class="level3">
<h3 class="anchored" data-anchor-id="dataframes-and-series">DataFrames and Series</h3>
<p>A <strong>DataFrame</strong> is Pandas’ primary data structure. It represents data in a two-dimensional, tabular form, with rows and columns. Each column has a name (the column label), and each row has an index that identifies it.</p>
<p>Within a DataFrame, each column is represented as a <strong>Series</strong>. A Series is a one-dimensional array of values with an associated index. While DataFrames represent entire datasets, Series represent individual variables within those datasets.</p>
<p>The distinction is important: - A DataFrame represents the whole table. - A Series represents a single column from that table.</p>
<p>This structure allows Pandas to apply operations across columns, across rows, or to individual variables in a consistent way. For example, summary statistics can be computed column by column, and filters can be applied row by row.</p>
<p>The following example illustrates the creation of a simple DataFrame with two columns:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">"a"</span>: [<span class="dv">1</span>, <span class="dv">2</span>], <span class="st">"b"</span>: [<span class="dv">3</span>, <span class="dv">4</span>]})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example:<br>
- The DataFrame has two columns, labeled <code>a</code> and <code>b</code>.<br>
- Each column is a Series containing numeric values.<br>
- Each row represents a single observation.</p>
<p>Although this example is small, the same structure scales to datasets with thousands or millions of rows. The consistent organization of rows and columns is what enables Pandas to support efficient data manipulation and analysis.</p>
<hr>
</section>
</section>
<section id="files-and-paths-in-data-workflows" class="level2">
<h2 class="anchored" data-anchor-id="files-and-paths-in-data-workflows">Files and Paths in Data Workflows</h2>
<p>As you begin working with real datasets, managing how and where data is stored becomes a critical part of the workflow. Data used in analytics and AI is almost always stored in external files rather than embedded directly in code. Understanding how Python locates and accesses these files is essential for building reliable and reproducible data workflows.</p>
<section id="why-file-paths-matter-for-data" class="level3">
<h3 class="anchored" data-anchor-id="why-file-paths-matter-for-data">Why file paths matter for data</h3>
<p>In most data workflows, Python scripts and data files are separate. A script contains instructions for what to do, while data files contain the information to be processed. File paths are what connect the two.</p>
<p>A <strong>file path</strong> is a description of where a file lives on a computer. When a script loads a dataset, it uses a file path to tell Python where to find that file. If the path is incorrect, the script cannot access the data, regardless of whether the file exists somewhere else on the system.</p>
<p>This separation between code and data is intentional. It allows:<br>
- the same code to be reused with different datasets,<br>
- data to be updated without changing code,<br>
- projects to be organized into clear directory structures.</p>
<p>Correctly managing file paths is therefore not just a technical detail; it is part of designing a clean and maintainable data workflow.</p>
</section>
<section id="relative-vs-absolute-paths-revisited" class="level3">
<h3 class="anchored" data-anchor-id="relative-vs-absolute-paths-revisited">Relative vs absolute paths (revisited)</h3>
<p>Recall that file paths can be either <strong>absolute</strong> or <strong>relative</strong>.</p>
<p>An <strong>absolute path</strong> specifies the full location of a file starting from the root of the file system. Absolute paths are precise, but they are tied to a specific machine and directory layout. This makes them fragile when projects are moved or shared.</p>
<p>A <strong>relative path</strong> specifies a file’s location relative to the current working directory of the script. Relative paths are preferred in most projects because they make code portable. As long as the internal project structure remains the same, relative paths continue to work across machines and environments.</p>
<p>In data workflows, relative paths are especially important because datasets are often stored in project subfolders such as <code>data/</code>. A typical pattern is to keep data files separate from scripts, but within the same project directory.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data_path <span class="op">=</span> <span class="st">"data/sample.csv"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This example assumes that the script is being run from the project’s root directory and that the dataset is located in a folder named <code>data</code>. Using relative paths in this way allows the entire project to be moved or shared without modifying file references.</p>
</section>
<section id="common-file-path-errors-also-revisted" class="level3">
<h3 class="anchored" data-anchor-id="common-file-path-errors-also-revisted">Common file path errors (also revisted)</h3>
<p>File path issues are among the most common sources of errors in data workflows. These errors are predictable and usually easy to diagnose once you know what to look for.</p>
<p>One frequent error is <strong>file not found</strong>. This occurs when Python cannot locate the file at the specified path. Common causes include misspelled file names, incorrect extensions, or incorrect assumptions about where the file is stored.</p>
<p>Another common issue is running a script from the <strong>wrong working directory</strong>. Relative paths are interpreted based on the directory from which the script is executed, not the location of the script file itself. If the working directory is not what you expect, relative paths may fail even if the file exists.</p>
<p>When debugging file access issues, it is often helpful to inspect the current working directory and list the files Python can see:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(os.getcwd())</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(os.listdir())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These checks help confirm whether the script is looking in the correct place and whether the expected files are present.</p>
<p>A useful debugging strategy is to temporarily use an absolute path to confirm that the file can be loaded at all. Once the issue is resolved, the path can be converted back to a relative one to restore portability.</p>
<p>Understanding and resolving file path errors reinforces an important lesson: many data-loading problems are not caused by Pandas or Python itself, but by mismatches between assumptions about directory structure and the actual execution context.</p>
<hr>
</section>
</section>
<section id="loading-data-from-csv-files" class="level2">
<h2 class="anchored" data-anchor-id="loading-data-from-csv-files">Loading Data from CSV Files</h2>
<p>One of the most common ways datasets are stored and shared is through <strong>CSV files</strong>. CSV files are simple, flexible, and widely supported, which makes them a standard format in analytics workflows.</p>
<section id="csv-files-as-datasets" class="level3">
<h3 class="anchored" data-anchor-id="csv-files-as-datasets">CSV files as datasets</h3>
<p>A <strong>CSV file</strong> (Comma-Separated Values) represents a dataset in a plain-text format. Each line in the file corresponds to a row in the dataset, and values within a row are separated by commas. Typically, the first row contains column names that describe the variables in the dataset.</p>
<p>Conceptually, a CSV file maps directly to the idea of a tabular dataset:</p>
<ul>
<li>each row represents an observation,<br>
</li>
<li>each column represents a variable,<br>
</li>
<li>and each cell contains a single value.</li>
</ul>
<p>Because CSV files are plain text, they are easy to create, inspect, and share. They can be opened in spreadsheet software, text editors, and programming environments without requiring specialized tools.</p>
<p>However, CSV files also have limitations. They do not explicitly store data types, constraints, or relationships between columns. Everything in a CSV file is initially read as text, and structure must be inferred by the software that loads it. This is why inspection and cleaning steps are so important after loading data.</p>
<p>Despite these limitations, CSV files remain a foundational format for analytics because they strike a balance between simplicity and usefulness.</p>
</section>
<section id="reading-csv-files-with-pandas" class="level3">
<h3 class="anchored" data-anchor-id="reading-csv-files-with-pandas">Reading CSV files with Pandas</h3>
<p>Pandas provides a dedicated function for loading CSV files into a DataFrame: <code>read_csv</code>. This function reads the contents of a CSV file and constructs a DataFrame where:<br>
- rows correspond to records,<br>
- columns correspond to variables,<br>
- and column labels are inferred from the header row.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">"data/sample.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, the CSV file located at <code>data/sample.csv</code> is read into a DataFrame named <code>df</code>. From this point forward, the dataset can be manipulated using Pandas operations rather than low-level file handling.</p>
<p>Assigning the result of <code>read_csv</code> to a variable is essential. The DataFrame becomes the central object through which all subsequent inspection, cleaning, transformation, and analysis steps are performed.</p>
<p>Although <code>read_csv</code> has many optional parameters, the default behavior is sufficient for many well-formed datasets. Additional options can be introduced later as data complexity increases.</p>
</section>
<section id="verifying-successful-data-loading" class="level3">
<h3 class="anchored" data-anchor-id="verifying-successful-data-loading">Verifying successful data loading</h3>
<p>After loading a dataset, it is important to <strong>verify that the data was read correctly</strong>. This step helps catch issues early, before errors propagate through later analysis.</p>
<p>Two simple checks are especially useful. First, examining the <strong>shape</strong> of the DataFrame confirms the number of rows and columns:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The shape provides a quick sanity check. If the number of rows or columns is unexpected, it may indicate a problem with the file path, the delimiter, or the structure of the CSV file.</p>
<p>Second, inspecting the <strong>column names</strong> helps verify that variables were read correctly:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>df.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This allows you to confirm that column labels match expectations and that no unexpected formatting issues occurred.</p>
<p>At this stage, the goal is not to deeply analyze the data, but to establish confidence that the dataset is present, structured, and ready for further inspection. Verifying successful data loading is a small step that prevents much larger problems later in the workflow.</p>
<hr>
</section>
</section>
<section id="data-cleaning-and-exploration" class="level2">
<h2 class="anchored" data-anchor-id="data-cleaning-and-exploration">Data Cleaning and Exploration</h2>
<p>Once a dataset has been loaded into a DataFrame, the next step is to <strong>understand what you are working with</strong>. Data cleaning and exploration begin not by changing anything, but by inspecting structure, contents, and basic properties of the data.</p>
<p>This section introduces a small set of inspection tools that provide high-value information early in the workflow. These tools help establish expectations, reveal potential problems, and guide subsequent cleaning and transformation steps.</p>
<section id="inspecting-data-structure" class="level3">
<h3 class="anchored" data-anchor-id="inspecting-data-structure">Inspecting data structure</h3>
<p>The first task after loading a dataset is to examine its overall structure. This involves looking at both the data itself and the metadata Pandas has inferred about it. Data inspection is iterative; unexpected results in summaries or plots should prompt analysts to revisit structure, missing values, and transformations rather than proceeding directly to modeling.</p>
<p>One common starting point is to view the <strong>first few rows</strong> of the dataset. This provides a quick sense of what each column represents and how values are formatted.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The output of <code>head()</code> shows the first rows of the DataFrame, including column names and sample values. This makes it easier to spot obvious issues such as unexpected column names, misaligned values, or formatting problems.</p>
<p>Another essential inspection step is examining the <strong>data types and completeness</strong> of each column.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>info()</code> method provides a summary of the DataFrame, including:<br>
- the number of rows,<br>
- the names of columns,<br>
- the data type inferred for each column,<br>
- and the count of non-missing values.</p>
<p>This information is critical for understanding how Pandas interprets the dataset. For example, a column intended to represent numbers may be interpreted as text, or a column may contain fewer non-null values than expected.</p>
<p>At this stage, the goal is not to fix problems, but to <strong>identify them</strong>. Inspection establishes a baseline understanding of the dataset before any modifications are made.</p>
</section>
<section id="descriptive-summaries" class="level3">
<h3 class="anchored" data-anchor-id="descriptive-summaries">Descriptive summaries</h3>
<p>After inspecting structure and types, it is useful to examine <strong>summary statistics</strong>. Descriptive summaries condense large amounts of data into a small number of informative metrics.</p>
<p>Pandas provides the <code>describe()</code> method for this purpose.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>df.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For numeric columns, <code>describe()</code> typically reports: - count, - mean, - standard deviation, - minimum and maximum values, - and key percentiles.</p>
<p>These summaries help reveal the distribution and scale of the data. Extremely large or small values, unexpected ranges, or missing observations can often be identified at this stage.</p>
<p>By default, <code>describe()</code> focuses on numeric data. Non-numeric columns, such as strings or categorical labels, require different inspection strategies. This distinction reinforces an important idea: <strong>different types of data require different forms of analysis</strong>.</p>
<p>Descriptive summaries do not provide answers on their own, but they guide reasoning. They help determine whether values look reasonable, whether further cleaning is required, and which variables may be relevant for analysis.</p>
<p>Together, inspection and descriptive summaries form the foundation of data cleaning. Before transforming or modeling data, it is essential to know what the data contains, how it is structured, and where potential issues may lie.</p>
<hr>
</section>
</section>
<section id="handling-missing-values" class="level2">
<h2 class="anchored" data-anchor-id="handling-missing-values">Handling Missing Values</h2>
<p>Missing data is a common and unavoidable feature of real-world datasets. Values may be absent for many reasons, and how missing data is handled can significantly influence analytical results and model behavior. This section introduces missing values as a concept, shows how to detect them, and outlines simple, practical strategies for dealing with them.</p>
<p>The emphasis here is not on finding a single “correct” solution, but on understanding the <strong>tradeoffs</strong> involved in different approaches.</p>
<section id="what-missing-data-represents" class="level3">
<h3 class="anchored" data-anchor-id="what-missing-data-represents">What missing data represents</h3>
<p>A <strong>missing value</strong> indicates that a data point is absent where a value is expected. In Pandas, missing values are typically represented using special markers that indicate the absence of data rather than a meaningful value.</p>
<p>Missing data can occur for many reasons:<br>
- information was not collected,<br>
- a measurement failed or was skipped,<br>
- data was lost during transfer or processing,<br>
- a value was not applicable in a particular context.</p>
<p>Importantly, missing values are not the same as zero, empty strings, or false values. They represent <strong>unknown or unavailable information</strong>, and treating them as ordinary values can lead to incorrect conclusions.</p>
<p>Missing data has important implications for analytics and AI systems. Many statistical operations and models assume complete data, and missing values can cause calculations to fail or produce misleading results. For example, averages may be skewed, relationships may appear weaker or stronger than they truly are, and models may learn patterns based on incomplete information.</p>
<p>Understanding what missing data represents is the first step toward deciding how to handle it responsibly.</p>
</section>
<section id="detecting-missing-values" class="level3">
<h3 class="anchored" data-anchor-id="detecting-missing-values">Detecting missing values</h3>
<p>Before missing data can be addressed, it must be identified. Pandas provides tools to detect and summarize missing values across a dataset.</p>
<p>A common approach is to check which values are missing and count how many missing values appear in each column.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df.isna().<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>isna()</code> method returns a DataFrame of boolean values indicating whether each entry is missing. When combined with <code>sum()</code>, it produces a count of missing values for each column.</p>
<p>This summary helps answer key questions:<br>
- Which columns contain missing values?<br>
- How many values are missing in each column?<br>
- Are missing values concentrated in specific variables or spread throughout the dataset?</p>
<p>Detecting missing values early allows informed decisions about whether data cleaning is required and which variables may need special attention.</p>
</section>
<section id="simple-strategies-for-handling-missing-data" class="level3">
<h3 class="anchored" data-anchor-id="simple-strategies-for-handling-missing-data">Simple strategies for handling missing data</h3>
<p>Once missing values have been identified, several basic strategies can be used to handle them. Each approach has advantages and disadvantages, and the appropriate choice depends on the context and goals of the analysis.</p>
<p>One simple strategy is <strong>dropping rows or columns</strong> that contain missing values. This approach is straightforward, but it can result in the loss of potentially valuable data, especially if missing values are common.</p>
<p>Another approach is <strong>filling missing values</strong> with a substitute value. For numeric data, this might involve using a constant, an average, or another summary statistic. For categorical data, a placeholder value may be used. Filling allows the dataset to remain complete, but it introduces assumptions about what the missing values should represent.</p>
<p>Both strategies involve tradeoffs:<br>
- Dropping data reduces sample size but avoids introducing assumptions.<br>
- Filling data preserves sample size but may distort distributions or relationships.</p>
<p>At this stage, the goal is not to apply advanced imputation techniques, but to develop an awareness of how missing data affects analysis and why handling it requires deliberate choice. Simple strategies provide a starting point and help illustrate the consequences of different decisions.</p>
<p>Handling missing values is an essential step in preparing data for analysis and modeling. Thoughtful treatment of missing data improves the reliability and interpretability of results and lays the groundwork for more advanced techniques later.</p>
<hr>
</section>
</section>
<section id="renaming-and-dropping-columns" class="level2">
<h2 class="anchored" data-anchor-id="renaming-and-dropping-columns">Renaming and Dropping Columns</h2>
<p>After inspecting a dataset and addressing missing values, a common next step is to clean up the <strong>columns themselves</strong>. Column names and column selection play a central role in how readable, interpretable, and usable a dataset is. This section focuses on improving dataset clarity by renaming columns and removing those that are unnecessary.</p>
<section id="why-column-names-matter" class="level3">
<h3 class="anchored" data-anchor-id="why-column-names-matter">Why column names matter</h3>
<p>Column names are not just labels; they are part of the dataset’s <strong>schema</strong>. They communicate what each variable represents and how it should be interpreted. Clear, consistent column names make data easier to understand, easier to analyze, and less error-prone to work with.</p>
<p>Poorly chosen column names can introduce confusion. Names may be too vague, too long, inconsistently formatted, or reflect internal system conventions rather than analytical meaning. For example, column names inherited from raw data sources may include abbreviations, spaces, or special characters that make code harder to read and write.</p>
<p>Improving column names serves several purposes:<br>
- It increases readability for humans.<br>
- It reduces the likelihood of mistakes when referencing columns in code.<br>
- It clarifies the intended meaning of each variable.</p>
<p>Because column names are used repeatedly throughout an analysis, treating them as part of the schema—and cleaning them early—pays dividends later in the workflow.</p>
</section>
<section id="renaming-columns" class="level3">
<h3 class="anchored" data-anchor-id="renaming-columns">Renaming columns</h3>
<p>Renaming columns is a common data-cleaning task. Pandas allows columns to be renamed by providing a mapping from old names to new names. This approach supports <strong>incremental cleanup</strong>, where only problematic columns are renamed rather than rewriting the entire schema at once.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>df.rename(columns<span class="op">=</span>{<span class="st">"old"</span>: <span class="st">"new"</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, the column originally named <code>"old"</code> is renamed to <code>"new"</code>. Other columns remain unchanged. This targeted approach makes it easier to track changes and reduces the risk of unintended consequences.</p>
<p>Renaming columns is often used to:<br>
- replace cryptic or abbreviated names with descriptive ones,<br>
- standardize capitalization or naming conventions,<br>
- remove spaces or special characters,<br>
- align column names with analytical concepts rather than source-system terminology.</p>
<p>Performing renaming early in the analysis ensures that subsequent code is easier to read and that variable references are consistent throughout the project.</p>
</section>
<section id="dropping-columns" class="level3">
<h3 class="anchored" data-anchor-id="dropping-columns">Dropping columns</h3>
<p>Not all columns in a dataset are useful for every analysis. Some columns may be redundant, irrelevant, or simply not needed for the current task. <strong>Dropping columns</strong> reduces dataset complexity and helps focus attention on the variables that matter.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>df.drop(columns<span class="op">=</span>[<span class="st">"unused"</span>], inplace<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, the column named <code>"unused"</code> is removed from the DataFrame. Dropping unnecessary columns can: - reduce memory usage,<br>
- simplify inspection and analysis,<br>
- make code easier to understand,<br>
- and reduce the risk of accidentally using irrelevant variables.</p>
<p>Deciding which columns to drop is a substantive analytical decision. Removing data too aggressively can eliminate useful information, while keeping too many columns can obscure important patterns. Don’t make these decision too quickly.</p>
<p>Renaming and dropping columns are small operations individually, but together they play a crucial role in shaping a dataset that is well-structured, interpretable, and ready for further transformation and analysis.</p>
<hr>
</section>
</section>
<section id="data-transformation-filtering-and-selecting-data" class="level2">
<h2 class="anchored" data-anchor-id="data-transformation-filtering-and-selecting-data">Data Transformation: Filtering and Selecting Data</h2>
<p>Once a dataset has been loaded, inspected, and cleaned, the next step is often to <strong>focus on the parts of the data that matter for a specific question</strong>. Data transformation involves selecting relevant variables, filtering observations, and reshaping datasets to support analysis.</p>
<p>This section introduces basic selection and filtering techniques in Pandas, emphasizing how these operations help turn raw datasets into analytically useful subsets.</p>
<section id="selecting-columns" class="level3">
<h3 class="anchored" data-anchor-id="selecting-columns">Selecting columns</h3>
<p>Selecting columns allows you to focus on a subset of variables within a dataset. Rather than working with every column at once, column selection narrows attention to the variables that are relevant for a particular analysis.</p>
<p>Column selection matters for several reasons:<br>
- It improves readability by reducing clutter.<br>
- It makes code more explicit about which variables are being used.<br>
- It reduces the chance of accidentally incorporating irrelevant data.</p>
<p>In Pandas, selecting columns produces a new DataFrame or Series that contains only the specified variables. This operation does not change the original dataset unless explicitly assigned back to it.</p>
<p>Conceptually, selecting columns answers the question:<br>
<em>Which variables from this dataset are relevant right now?</em></p>
<p>Focusing on relevant columns is an important analytical habit. It encourages intentional use of data rather than treating all available variables as equally important.</p>
</section>
<section id="filtering-rows-with-conditions" class="level3">
<h3 class="anchored" data-anchor-id="filtering-rows-with-conditions">Filtering rows with conditions</h3>
<p>Filtering rows allows you to select observations that meet specific criteria. Instead of analyzing all rows in a dataset, filtering narrows the dataset to those records that satisfy a condition.</p>
<p>In Pandas, row filtering is typically done using <strong>boolean masks</strong>. A boolean mask is a sequence of True and False values that indicates whether each row meets a condition.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>filtered <span class="op">=</span> df[df[<span class="st">"score"</span>] <span class="op">&gt;</span> <span class="dv">80</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, the condition <code>df["score"] &gt; 80</code> produces a boolean mask. Pandas uses this mask to keep only the rows where the condition is true.</p>
<p>Filtering rows is a powerful way to explore subsets of data, such as:<br>
- high-performing observations,<br>
- records from a specific category,<br>
- or cases that meet defined thresholds.</p>
<p>Conceptually, filtering answers the question:<br>
<em>Which observations should be included in this analysis?</em></p>
<p>Because filtering is based on conditions, it directly connects to the conditional logic introduced earlier in the book.</p>
</section>
<section id="using-.loc-and-.iloc" class="level3">
<h3 class="anchored" data-anchor-id="using-.loc-and-.iloc">Using .loc and .iloc</h3>
<p>Pandas provides two explicit indexing tools for selecting data: <code>.loc</code> and <code>.iloc</code>. These tools clarify whether selection is based on <strong>labels</strong> or <strong>positions</strong>.</p>
<ul>
<li><code>.loc</code> is used for <strong>label-based selection</strong>. It selects rows and columns using index labels and column names.</li>
<li><code>.iloc</code> is used for <strong>position-based selection</strong>. It selects rows and columns using integer positions, similar to list indexing.</li>
</ul>
<p>Choosing between <code>.loc</code> and <code>.iloc</code> depends on context:<br>
- Use <code>.loc</code> when working with meaningful labels.<br>
- Use <code>.iloc</code> when selection depends on row or column position.</p>
<p>Although basic filtering and selection can be done without these methods, <code>.loc</code> and <code>.iloc</code> become increasingly important as datasets grow more complex and analyses become more detailed.</p>
<hr>
</section>
</section>
<section id="descriptive-statistics-with-pandas" class="level2">
<h2 class="anchored" data-anchor-id="descriptive-statistics-with-pandas">Descriptive Statistics with Pandas</h2>
<p>After data has been cleaned, filtered, and transformed, the next step is often to <strong>summarize what the data contains</strong>. Descriptive statistics provide a way to move from raw rows and columns to interpretable information that supports reasoning and decision-making.</p>
<section id="why-summarization-matters" class="level3">
<h3 class="anchored" data-anchor-id="why-summarization-matters">Why summarization matters</h3>
<p>Raw datasets can be large and difficult to interpret directly. Even after filtering and cleaning, looking at individual rows rarely provides a clear picture of overall patterns or tendencies.</p>
<p><strong>Summarization</strong> condenses many observations into a small number of meaningful quantities. These summaries help answer questions such as:<br>
- What is typical in this dataset?<br>
- How much variation exists?<br>
- Are values generally large or small?<br>
- Are there obvious extremes or anomalies?</p>
<p>Descriptive statistics are often the first step in turning data into insight. They provide critical context before more advanced analysis is attempted. In analytics and AI workflows, descriptive summaries help analysts understand what the model will see and what assumptions may be reasonable.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Don’t skip this step! This is often overlooked as being too simple, and not providing the same rich detail a more complicated model provides. But often, this kind of simple is exactly what is needed.</p>
</div>
</div>
</section>
<section id="common-summary-statistics" class="level3">
<h3 class="anchored" data-anchor-id="common-summary-statistics">Common summary statistics</h3>
<p>Pandas provides convenient methods for computing common descriptive statistics. These statistics describe central tendency, spread, and range.</p>
<p>Some of the most frequently used summary statistics include:<br>
- <strong>count</strong>, the number of non-missing values,<br>
- <strong>mean</strong>, the average value,<br>
- <strong>median</strong>, the middle value,<br>
- <strong>minimum</strong> and <strong>maximum</strong>, which describe the range of values.</p>
<p>For example, computing the average of a numeric column can be done directly:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"score"</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These operations aggregate information across all rows in a column, producing a single value that summarizes the data. Similar methods exist for other statistics, and many can be applied column by column across an entire DataFrame.</p>
<p>Summary statistics are especially useful for identifying potential issues: - unexpected ranges,<br>
- unusually large or small values,<br>
- or discrepancies between measures such as mean and median.</p>
<p>While these statistics are simple, they play an essential role in exploratory analysis. They help determine whether further cleaning is needed and guide decisions about what analyses are appropriate.</p>
</section>
<section id="group-level-summaries-conceptual-preview" class="level3">
<h3 class="anchored" data-anchor-id="group-level-summaries-conceptual-preview">Group-level summaries (conceptual preview)</h3>
<p>In many datasets, observations belong to meaningful <strong>groups or categories</strong>. For example, data may be grouped by region, category, or time period. Summarizing data across the entire dataset can obscure important differences between groups.</p>
<p>Group-level summaries address this by computing descriptive statistics <strong>within categories</strong> rather than across all observations at once. This allows comparisons such as:<br>
- average scores by group,<br>
- counts by category,<br>
- or ranges within subpopulations.</p>
<p>Group-level summaries allow analysts to move from “overall” descriptions to more nuanced views that reveal structure within the data.</p>
<p>Group-level summaries prepare the ground for deeper analysis, including comparisons, modeling, and evaluation. They represent a natural progression from understanding individual variables to understanding relationships between variables and categories.</p>
</section>
</section>
<section id="chapter-summary" class="level2">
<h2 class="anchored" data-anchor-id="chapter-summary">Chapter Summary</h2>
<p>This chapter focused on working with <strong>data as an object of analysis</strong>, rather than as isolated values or small collections. The emphasis shifted from writing Python logic to understanding how real-world data is structured, accessed, cleaned, transformed, and summarized in preparation for analytics and AI tasks.</p>
<p>Conceptually, the chapter introduced datasets as structured collections of observations governed by a schema. Understanding rows as records and columns as variables provided a foundation for reasoning about data quality, consistency, and meaning. The distinction between structured and unstructured data clarified why tools like Pandas are central to analytics workflows and how unstructured data is often transformed before analysis.</p>
<p>Pandas was introduced as a way to treat datasets as first-class objects through DataFrames and Series. This abstraction made it possible to load data from external files, inspect structure and types, handle missing values, and clean schemas in a systematic way. Rather than viewing data cleaning as a peripheral task, the chapter emphasized it as a core part of responsible analysis.</p>
<p>The chapter also highlighted how <strong>data location and access</strong> shape workflows. File paths and relative directories were treated as integral components of data pipelines rather than technical afterthoughts. Understanding how data is retrieved from CSV files expanded the range of data sources that Python programs can work with.</p>
<p>Through filtering, selection, and descriptive statistics, the chapter demonstrated how raw datasets are transformed into interpretable summaries. These summaries do not provide final answers, but they support sense-making, guide further analysis, and surface potential data quality issues. The mini-lab reinforced this end-to-end workflow by integrating import, inspection, cleaning, transformation, and interpretation into a single analytical process.</p>
<p>Data workflows form a dependency chain: choices made during loading and cleaning directly shape summaries, visualizations, and interpretations later in the analysis. This is often overlooked, even though it seems obvious on the surface.</p>
<p>By the end of this chapter, you should be able to move confidently from raw data to cleaned, summarized information, while understanding how each step affects the results. These skills form the foundation for the next stage of the book, where datasets are no longer just described, but used to support modeling, prediction, and decision-making.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>