<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Week 4 – Simulation and Visualization: From Data to Insight – Foundations of Analytics &amp; AI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="access.theme.scss">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Foundations of Analytics &amp; AI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-weeks" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Weeks</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-weeks">    
        <li>
    <a class="dropdown-item" href="../textbook_src/week01_main.html">
 <span class="dropdown-text">Week 1. What is Analytics &amp; AI?</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/week02_main.html">
 <span class="dropdown-text">Week 2. Python Basics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/week03_main.html">
 <span class="dropdown-text">Week 3. Data Structures &amp; Pandas</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/week04_main.html">
 <span class="dropdown-text">Week 4. From Data to Models</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-guides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Guides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-guides">    
        <li>
    <a class="dropdown-item" href="../guides/install_python.html">
 <span class="dropdown-text">Install Python</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/install_requirements.html">
 <span class="dropdown-text">Installing requirements.txt</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/using_colab.html">
 <span class="dropdown-text">Using Colab</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#week-4-overview" id="toc-week-4-overview" class="nav-link active" data-scroll-target="#week-4-overview">Week 4 Overview</a>
  <ul class="collapse">
  <li><a href="#what-you-will-learn-this-week" id="toc-what-you-will-learn-this-week" class="nav-link" data-scroll-target="#what-you-will-learn-this-week">What you will learn this week</a></li>
  <li><a href="#what-you-will-produce-this-week" id="toc-what-you-will-produce-this-week" class="nav-link" data-scroll-target="#what-you-will-produce-this-week">What you will produce this week</a></li>
  <li><a href="#ai-literacy-objectives" id="toc-ai-literacy-objectives" class="nav-link" data-scroll-target="#ai-literacy-objectives">AI Literacy Objectives</a></li>
  <li><a href="#job-ready-skills-objectives" id="toc-job-ready-skills-objectives" class="nav-link" data-scroll-target="#job-ready-skills-objectives">Job-Ready Skills Objectives</a></li>
  </ul></li>
  <li><a href="#data-simulation-simulating-data-and-random-processes" id="toc-data-simulation-simulating-data-and-random-processes" class="nav-link" data-scroll-target="#data-simulation-simulating-data-and-random-processes">1. Data Simulation: Simulating Data and Random Processes</a>
  <ul class="collapse">
  <li><a href="#why-simulate-data" id="toc-why-simulate-data" class="nav-link" data-scroll-target="#why-simulate-data">1.1 Why simulate data</a></li>
  <li><a href="#randomness-and-stochastic-processes" id="toc-randomness-and-stochastic-processes" class="nav-link" data-scroll-target="#randomness-and-stochastic-processes">1.2 Randomness and stochastic processes</a></li>
  <li><a href="#generating-synthetic-datasets" id="toc-generating-synthetic-datasets" class="nav-link" data-scroll-target="#generating-synthetic-datasets">1.3 Generating synthetic datasets</a></li>
  </ul></li>
  <li><a href="#visualization-foundations-why-visualization-matters" id="toc-visualization-foundations-why-visualization-matters" class="nav-link" data-scroll-target="#visualization-foundations-why-visualization-matters">2. Visualization Foundations: Why Visualization Matters</a>
  <ul class="collapse">
  <li><a href="#visualization-as-a-reasoning-tool" id="toc-visualization-as-a-reasoning-tool" class="nav-link" data-scroll-target="#visualization-as-a-reasoning-tool">2.1 Visualization as a reasoning tool</a></li>
  <li><a href="#visualization-in-analytics-and-ai" id="toc-visualization-in-analytics-and-ai" class="nav-link" data-scroll-target="#visualization-in-analytics-and-ai">2.2 Visualization in analytics and AI</a></li>
  </ul></li>
  <li><a href="#matplotlib-basics-simple-plots" id="toc-matplotlib-basics-simple-plots" class="nav-link" data-scroll-target="#matplotlib-basics-simple-plots">3. Matplotlib Basics: Simple Plots</a>
  <ul class="collapse">
  <li><a href="#what-matplotlib-is" id="toc-what-matplotlib-is" class="nav-link" data-scroll-target="#what-matplotlib-is">3.1 What matplotlib is</a></li>
  <li><a href="#line-plots" id="toc-line-plots" class="nav-link" data-scroll-target="#line-plots">3.2 Line plots</a></li>
  <li><a href="#bar-plots" id="toc-bar-plots" class="nav-link" data-scroll-target="#bar-plots">3.3 Bar plots</a></li>
  <li><a href="#scatter-plots" id="toc-scatter-plots" class="nav-link" data-scroll-target="#scatter-plots">3.4 Scatter plots</a></li>
  </ul></li>
  <li><a href="#matplotlib-basics-customizing-plots" id="toc-matplotlib-basics-customizing-plots" class="nav-link" data-scroll-target="#matplotlib-basics-customizing-plots">4. Matplotlib Basics: Customizing Plots</a>
  <ul class="collapse">
  <li><a href="#why-customization-matters" id="toc-why-customization-matters" class="nav-link" data-scroll-target="#why-customization-matters">4.1 Why customization matters</a></li>
  <li><a href="#titles-labels-and-legends" id="toc-titles-labels-and-legends" class="nav-link" data-scroll-target="#titles-labels-and-legends">4.2 Titles, labels, and legends</a></li>
  <li><a href="#colors-and-styles" id="toc-colors-and-styles" class="nav-link" data-scroll-target="#colors-and-styles">4.3 Colors and styles</a></li>
  </ul></li>
  <li><a href="#seaborn-statistical-visualization-optional" id="toc-seaborn-statistical-visualization-optional" class="nav-link" data-scroll-target="#seaborn-statistical-visualization-optional">5. Seaborn: Statistical Visualization <em>(Optional)</em></a>
  <ul class="collapse">
  <li><a href="#why-seaborn-exists" id="toc-why-seaborn-exists" class="nav-link" data-scroll-target="#why-seaborn-exists">5.1 Why seaborn exists</a></li>
  <li><a href="#distribution-plots" id="toc-distribution-plots" class="nav-link" data-scroll-target="#distribution-plots">5.2 Distribution plots</a></li>
  </ul></li>
  <li><a href="#integrated-workflow-from-data-to-visualization" id="toc-integrated-workflow-from-data-to-visualization" class="nav-link" data-scroll-target="#integrated-workflow-from-data-to-visualization">6. Integrated Workflow: From Data to Visualization</a>
  <ul class="collapse">
  <li><a href="#simulate-or-load-a-dataset" id="toc-simulate-or-load-a-dataset" class="nav-link" data-scroll-target="#simulate-or-load-a-dataset">6.1 Simulate or load a dataset</a></li>
  <li><a href="#summarize-before-visualizing" id="toc-summarize-before-visualizing" class="nav-link" data-scroll-target="#summarize-before-visualizing">6.2 Summarize before visualizing</a></li>
  <li><a href="#visualize-insights" id="toc-visualize-insights" class="nav-link" data-scroll-target="#visualize-insights">6.3 Visualize insights</a></li>
  </ul></li>
  <li><a href="#mini-lab-raw-data-to-visual-insights" id="toc-mini-lab-raw-data-to-visual-insights" class="nav-link" data-scroll-target="#mini-lab-raw-data-to-visual-insights">7. Mini-Lab: Raw Data to Visual Insights</a>
  <ul class="collapse">
  <li><a href="#simulating-a-dataset" id="toc-simulating-a-dataset" class="nav-link" data-scroll-target="#simulating-a-dataset">7.1 Simulating a dataset</a></li>
  <li><a href="#cleaning-and-summarizing" id="toc-cleaning-and-summarizing" class="nav-link" data-scroll-target="#cleaning-and-summarizing">7.2 Cleaning and summarizing</a></li>
  <li><a href="#visual-exploration" id="toc-visual-exploration" class="nav-link" data-scroll-target="#visual-exploration">7.3 Visual exploration</a></li>
  <li><a href="#interpreting-visual-results" id="toc-interpreting-visual-results" class="nav-link" data-scroll-target="#interpreting-visual-results">7.4 Interpreting visual results</a></li>
  </ul></li>
  <li><a href="#week-4-summary" id="toc-week-4-summary" class="nav-link" data-scroll-target="#week-4-summary">Week 4 Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Week 4 – Simulation and Visualization: From Data to Insight</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="week-4-overview" class="level2">
<h2 class="anchored" data-anchor-id="week-4-overview">Week 4 Overview</h2>
<section id="what-you-will-learn-this-week" class="level3">
<h3 class="anchored" data-anchor-id="what-you-will-learn-this-week">What you will learn this week</h3>
<ul>
<li>How to generate synthetic data using random processes.</li>
<li>Why simulation is useful for understanding uncertainty and systems.</li>
<li>How visualization supports reasoning, exploration, and communication.</li>
<li>How to create and customize plots using matplotlib and seaborn.</li>
<li>How to move from cleaned data to visual insight in an integrated workflow.</li>
<li>How these skills connect to machine learning and LLM-based systems.</li>
</ul>
</section>
<section id="what-you-will-produce-this-week" class="level3">
<h3 class="anchored" data-anchor-id="what-you-will-produce-this-week">What you will produce this week</h3>
<ul>
<li>Python scripts that simulate datasets.</li>
<li>Multiple visualizations (line, bar, scatter, statistical plots).</li>
<li>Customized plots designed for clarity and interpretation.</li>
<li>An end-to-end visual analytics workflow.</li>
<li>A mini-lab demonstrating raw data → insight.</li>
</ul>
</section>
<section id="ai-literacy-objectives" class="level3">
<h3 class="anchored" data-anchor-id="ai-literacy-objectives">AI Literacy Objectives</h3>
<p>By the end of this week, you should be able to:<br>
- Explain why simulation is useful for exploring uncertainty and behavior.<br>
- Describe how visualization supports analytical reasoning.<br>
- Interpret visual patterns and relate them to underlying data processes.<br>
- Explain how synthetic data is used in ML and AI development.</p>
</section>
<section id="job-ready-skills-objectives" class="level3">
<h3 class="anchored" data-anchor-id="job-ready-skills-objectives">Job-Ready Skills Objectives</h3>
<p>By the end of this week, you should be able to:<br>
- Generate synthetic datasets using Python.<br>
- Create basic plots using matplotlib.<br>
- Customize plots for readability and communication.<br>
- Use seaborn for statistical visualization.<br>
- Build a reproducible workflow from data generation to visualization.</p>
</section>
</section>
<section id="data-simulation-simulating-data-and-random-processes" class="level2">
<h2 class="anchored" data-anchor-id="data-simulation-simulating-data-and-random-processes">1. Data Simulation: Simulating Data and Random Processes</h2>
<p>Simulation is a powerful technique for exploring data-driven systems when real-world data is limited, expensive, sensitive, or simply unavailable. Rather than waiting for data to exist, simulation allows analysts to <strong>create data intentionally</strong> in order to understand behavior, uncertainty, and system dynamics.</p>
<p>This section introduces simulation as both a practical coding skill and a conceptual tool for reasoning about analytics and AI systems.</p>
<hr>
<section id="why-simulate-data" class="level3">
<h3 class="anchored" data-anchor-id="why-simulate-data">1.1 Why simulate data</h3>
<p>In an ideal world, every analytical question would be answered using high-quality, representative real-world data. In practice, this is rarely the case. Real datasets often come with limitations that make analysis difficult or incomplete.</p>
<p>Some common challenges include:<br>
- data that is incomplete or missing important cases,<br>
- data that is biased due to how it was collected,<br>
- data that is proprietary, sensitive, or restricted,<br>
- data that does not yet exist because the system is new or hypothetical.</p>
<p>Simulation provides a way to work around these limitations. By generating <strong>synthetic data</strong>, analysts can explore how systems behave under controlled assumptions. This makes it possible to ask “what if” questions, such as:<br>
- What happens if inputs change?<br>
- How sensitive are outcomes to randomness?<br>
- What patterns would we expect to see under certain conditions?</p>
<p>It is important to distinguish <strong>simulation</strong> from <strong>data collection</strong>. Data collection records what has already happened in the real world. Simulation, by contrast, creates plausible data based on assumptions about how a system might behave. Simulated data is not a replacement for real data, but it is a complementary tool.</p>
<p>In analytics and AI, simulation plays several important roles:<br>
- testing analysis logic before real data is available,<br>
- stress-testing models under different scenarios,<br>
- building intuition about variability and uncertainty,<br>
- generating training or evaluation data when real examples are scarce.</p>
<p>Conceptually, simulation answers the question:<br>
<em>If the world behaved according to these assumptions, what kinds of data and patterns would we observe?</em></p>
<p>Understanding simulation helps shift thinking away from treating datasets as fixed artifacts and toward seeing data as the result of underlying processes.</p>
<hr>
</section>
<section id="randomness-and-stochastic-processes" class="level3">
<h3 class="anchored" data-anchor-id="randomness-and-stochastic-processes">1.2 Randomness and stochastic processes</h3>
<p>At the heart of most simulations is <strong>randomness</strong>. In everyday language, randomness often implies unpredictability or lack of structure. In computation, randomness has a more precise meaning.</p>
<p>Computers do not generate truly random numbers. Instead, they use <strong>pseudo-random number generators</strong>, which produce sequences of numbers that <em>appear</em> random but are generated deterministically by an algorithm. These sequences are sufficiently unpredictable for most analytical purposes, while still being reproducible.</p>
<p>Python provides built-in tools for generating pseudo-random values. For example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>random.random()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each call to <code>random.random()</code> returns a floating-point number between 0 and 1. Over many calls, these values form a distribution that can be used to simulate uncertainty, noise, or variability in a system.</p>
<p>A process that involves randomness is often called a <strong>stochastic process</strong>. Stochastic processes are used to model systems where outcomes are influenced by chance, such as customer arrivals, demand fluctuations, or measurement error. Rather than producing a single deterministic outcome, stochastic processes produce distributions of possible outcomes.</p>
<p>An important concept related to pseudo-randomness is <strong>repeatability</strong>. Because random number generation is algorithmic, it can be controlled using a seed. Setting a seed causes the same sequence of “random” values to be generated each time the program runs. This is essential for debugging, testing, and scientific reproducibility.</p>
<p>At a conceptual level, randomness in simulation is not about chaos, it is about <strong>controlled variability</strong>. By introducing randomness deliberately, analysts can explore how systems behave across many possible realizations rather than relying on a single outcome.</p>
<p>This idea will recur throughout analytics and AI. Models often rely on random initialization, randomized sampling, or stochastic optimization. Understanding how randomness is generated and used in simulation builds intuition for why repeated runs may produce slightly different results and why variability itself is something to be analyzed rather than ignored.</p>
<hr>
</section>
<section id="generating-synthetic-datasets" class="level3">
<h3 class="anchored" data-anchor-id="generating-synthetic-datasets">1.3 Generating synthetic datasets</h3>
<p>Once randomness is available as a tool, the next step is to use it to generate <strong>synthetic datasets</strong>. A synthetic dataset is a collection of simulated observations designed to resemble data that might plausibly be observed from a real process.</p>
<p>Synthetic datasets are especially useful for experimentation. They allow analysts to explore patterns, test code, and validate logic without relying on external data sources. The goal is not realism for its own sake, but <strong>control and clarity</strong>.</p>
<hr>
<section id="simulating-numeric-variables" class="level4">
<h4 class="anchored" data-anchor-id="simulating-numeric-variables">Simulating numeric variables</h4>
<p>The simplest form of simulation involves generating numeric values. For example, random numbers between 0 and 1 can be used to represent proportions, probabilities, noise, or normalized measurements.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> [random.random() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, a list of 100 simulated values is created. Each value is generated independently, but together they form a dataset that can be summarized, visualized, or transformed.</p>
<p>Although this dataset is simple, it already supports many analytical questions:<br>
- What does the distribution look like?<br>
- How much variability is present?<br>
- How do summaries change as the number of observations increases?</p>
<p>Simulated numeric variables provide a controlled environment for developing intuition about distributions and variability.</p>
<hr>
</section>
<section id="simulating-categorical-variables" class="level4">
<h4 class="anchored" data-anchor-id="simulating-categorical-variables">Simulating categorical variables</h4>
<p>Not all data is numeric. Many datasets include <strong>categorical variables</strong>, such as labels, group memberships, or types. These can also be simulated by randomly assigning categories according to specified rules.</p>
<p>For example, categories might be assigned uniformly at random, or with different probabilities to reflect imbalance. Although the mechanics differ slightly from numeric simulation, the underlying idea is the same: define a process, then generate observations from it.</p>
<p>Categorical simulation is useful for:<br>
- testing grouping and aggregation logic,<br>
- exploring how category imbalance affects summaries,<br>
- preparing for visualization and comparison tasks.</p>
<p>Even when categories are simulated, they behave like real categorical data in downstream analysis.</p>
<hr>
</section>
<section id="combining-multiple-simulated-variables-into-datasets" class="level4">
<h4 class="anchored" data-anchor-id="combining-multiple-simulated-variables-into-datasets">Combining multiple simulated variables into datasets</h4>
<p>Real datasets rarely consist of a single variable. More commonly, each observation includes multiple attributes. Synthetic datasets can be constructed by simulating several variables independently or jointly and then combining them into a structured dataset.</p>
<p>For example, one variable might represent a numeric measurement, while another represents a category or group. Together, these variables form a dataset that more closely resembles real analytical inputs.</p>
<p>Combining simulated variables allows analysts to test how different components of an analysis interact:<br>
- filtering by category,<br>
- summarizing numeric values within groups,<br>
- visualizing relationships between variables.</p>
<p>At this stage, the emphasis is on structure rather than realism. The goal is to create datasets that support reasoning about code and analysis logic.</p>
<hr>
</section>
<section id="using-simulation-to-test-analysis-logic" class="level4">
<h4 class="anchored" data-anchor-id="using-simulation-to-test-analysis-logic">Using simulation to test analysis logic</h4>
<p>One of the most important uses of simulation is <strong>testing analysis logic before applying it to real data</strong>. Because synthetic data is generated under known assumptions, it becomes easier to reason about whether code behaves as intended.</p>
<p>For example: - If a filter is applied, does it select the expected data?<br>
- If a summary statistic is computed, does it behave sensibly as data size changes?<br>
- If a visualization is produced, does it reflect the underlying data-generating process?</p>
<p>Simulation turns analysis into an experiment. By controlling inputs and observing outputs, analysts can build confidence that their workflow is correct before introducing the messiness of real-world data.</p>
<p>This practice is common in analytics and AI development. Models, pipelines, and visualizations are often tested on synthetic data first, then refined using real data once logic is validated. Sometimes this is to test models viability for a certain task, and often this is related to the cost (in time, dollars, effort) to test a model on a real world dateset.</p>
<p>Conceptually, generating synthetic datasets answers the question: <em>If my analysis pipeline is correct, does it behave sensibly on data generated from known processes?</em> You could simply this to thinking about a synthetic data set as a data set you have created, with known relationships beween the variables. And now you want to understand if your model can identify/capture those relationships.</p>
<p>This mindset, testing logic under controlled conditions, will continue to be important as you continue to learn machine learning and AI.</p>
<hr>
</section>
</section>
</section>
<section id="visualization-foundations-why-visualization-matters" class="level2">
<h2 class="anchored" data-anchor-id="visualization-foundations-why-visualization-matters">2. Visualization Foundations: Why Visualization Matters</h2>
<p>As datasets grow in size and complexity, tables of numbers alone become difficult to interpret. Visualization provides a way to translate data into forms that align with human perception, making patterns, relationships, and anomalies easier to detect. This section introduces visualization as a core analytical tool rather than an optional presentation step.</p>
<hr>
<section id="visualization-as-a-reasoning-tool" class="level3">
<h3 class="anchored" data-anchor-id="visualization-as-a-reasoning-tool">2.1 Visualization as a reasoning tool</h3>
<p>Visualization supports <strong>reasoning</strong>, not just communication. While tables are precise and compact, they place a heavy cognitive burden on the reader. Detecting patterns in rows of numbers requires careful scanning and mental comparison, which becomes increasingly difficult as datasets grow.</p>
<p>Visual representations leverage the strengths of human perception. Humans are especially good at detecting:<br>
- trends and changes over time,<br>
- differences in magnitude,<br>
- clusters and outliers,<br>
- and relationships between variables.</p>
<p>By mapping data values to visual properties such as position, length, or shape, visualizations make these patterns immediately apparent. A trend that might be difficult to notice in a table often becomes obvious when plotted.</p>
<p>It is also important to distinguish between <strong>visualization for exploration</strong> and <strong>visualization for presentation</strong>. Exploratory visualizations are created to help the analyst understand the data. They may be rough, iterative, and rapidly discarded. Presentation visualizations, by contrast, are designed to communicate a specific message clearly to an audience.</p>
<p>In analytics and AI workflows, visualization often begins as an exploratory activity. Before formal modeling or reporting, visual inspection helps clarify what the data contains, what questions are reasonable, and where potential issues may lie.</p>
<p>Conceptually, visualization answers the question:<br>
<em>What patterns or structures might exist in this data that are hard to see numerically?</em></p>
<hr>
</section>
<section id="visualization-in-analytics-and-ai" class="level3">
<h3 class="anchored" data-anchor-id="visualization-in-analytics-and-ai">2.2 Visualization in analytics and AI</h3>
<p>Visualization plays a central role throughout analytics and AI pipelines. Early in the process, visualizations are used to examine <strong>distributions</strong>, <strong>trends</strong>, and <strong>relationships</strong> within data. These views help analysts understand scale, variability, and potential anomalies before applying statistical or machine learning models.</p>
<p>Visualization also functions as a <strong>diagnostic tool</strong>. Unexpected patterns in a plot may reveal data quality issues, incorrect assumptions, or errors in preprocessing. For example, a strange spike or gap in a distribution might indicate missing values, mis-coded categories, or unit mismatches.</p>
<p>In AI contexts, visualization remains important even after models are introduced. Visual diagnostics are often used to:<br>
- examine model inputs and outputs,<br>
- compare predicted values to actual outcomes,<br>
- assess residuals or errors,<br>
- and monitor model behavior over time.</p>
<p>Although models may operate mathematically, their behavior must still be interpreted by humans. Visualization provides one of the most effective ways to bridge this gap between computation and understanding.</p>
<p>Across analytics and AI, visualization serves a consistent purpose: it reduces complexity by externalizing patterns that would otherwise remain hidden in raw data or numerical summaries. Used thoughtfully, visualization supports better reasoning, better debugging, and better decisions.</p>
</section>
</section>
<section id="matplotlib-basics-simple-plots" class="level2">
<h2 class="anchored" data-anchor-id="matplotlib-basics-simple-plots">3. Matplotlib Basics: Simple Plots</h2>
<p>Matplotlib is one of the foundational libraries for creating visualizations in Python. While higher-level libraries exist, matplotlib provides the underlying plotting system on which many other visualization tools are built. Understanding its basics gives you direct control over how data is visualized and prepares you to reason about more advanced plotting tools later on.</p>
<p>This section introduces three of the most common plot types—line plots, bar plots, and scatter plots—and explains when each is appropriate.</p>
<hr>
<section id="what-matplotlib-is" class="level3">
<h3 class="anchored" data-anchor-id="what-matplotlib-is">3.1 What matplotlib is</h3>
<p>Matplotlib is a general-purpose plotting library designed to create static, two-dimensional visualizations. It allows Python programs to translate numerical data into visual form by mapping values to positions, shapes, and other visual properties.</p>
<p>At a high level, matplotlib works by creating a <strong>figure</strong>, which acts as a container for one or more plots, and <strong>axes</strong>, which define the coordinate system within that figure. Although these concepts can be explored in more detail later, it is sufficient at this stage to understand that every plot exists within a figure and is drawn on axes.</p>
<p>Matplotlib is intentionally flexible. This flexibility can make it feel verbose at first, but it also allows precise control over visual output. Many other visualization libraries build on top of matplotlib, so familiarity with its basic patterns is a long-term investment.</p>
<hr>
</section>
<section id="line-plots" class="level3">
<h3 class="anchored" data-anchor-id="line-plots">3.2 Line plots</h3>
<p>A <strong>line plot</strong> connects a sequence of data points with lines. Line plots are commonly used to visualize trends over time or over an ordered sequence of observations.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>plt.plot(values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, the values are plotted in the order they appear. The horizontal axis represents the position or index of each value, while the vertical axis represents the value itself.</p>
<p>Line plots are appropriate when:<br>
- the order of observations matters,<br>
- data represents a progression over time or sequence,<br>
- or the goal is to see trends, patterns, or changes.</p>
<p>Using a line plot for unordered categories can be misleading, because the connecting lines imply continuity where none exists. Choosing a line plot therefore reflects an assumption about the underlying data structure.</p>
<hr>
</section>
<section id="bar-plots" class="level3">
<h3 class="anchored" data-anchor-id="bar-plots">3.3 Bar plots</h3>
<p>A <strong>bar plot</strong> represents values associated with discrete categories using rectangular bars. Bar plots are commonly used to compare quantities across groups or categories.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>plt.bar([<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>], [<span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">7</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, each category is represented by a bar whose height corresponds to a value. Unlike line plots, bar plots do not imply continuity between categories. Each bar stands on its own.</p>
<p>Bar plots are appropriate when:<br>
- comparing values across categories,<br>
- visualizing aggregated statistics,<br>
- or emphasizing differences between groups.</p>
<p>Because bar plots emphasize magnitude differences, they are often used in descriptive analysis and reporting. Care should be taken to ensure that axes and scales are chosen thoughtfully, as visual exaggeration or compression can distort interpretation.</p>
<hr>
</section>
<section id="scatter-plots" class="level3">
<h3 class="anchored" data-anchor-id="scatter-plots">3.4 Scatter plots</h3>
<p>A <strong>scatter plot</strong> displays individual observations as points in a two-dimensional space. Each point represents a pair of values, one on the horizontal axis and one on the vertical axis.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(x, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Scatter plots are used to visualize <strong>relationships between variables</strong>. Patterns such as clustering, trends, or outliers are often visible in scatter plots even when they are not obvious numerically.</p>
<p>Scatter plots are appropriate when:<br>
- examining the relationship between two numeric variables,<br>
- exploring correlation or association,<br>
- or identifying unusual observations.</p>
<p>It is important to distinguish between <strong>correlation and causation</strong>. A visible relationship in a scatter plot does not imply that one variable causes the other to change. Scatter plots support exploration and hypothesis generation, not definitive conclusions.</p>
<p>Together, line plots, bar plots, and scatter plots form a basic visual vocabulary. Choosing the appropriate plot type is a substantive analytical decision that reflects assumptions about data structure and the questions being asked.</p>
</section>
</section>
<section id="matplotlib-basics-customizing-plots" class="level2">
<h2 class="anchored" data-anchor-id="matplotlib-basics-customizing-plots">4. Matplotlib Basics: Customizing Plots</h2>
<p>Creating a plot is only the first step in visualization. A plot that is technically correct can still be confusing, misleading, or difficult to interpret. <strong>Customization</strong> is what turns a raw plot into a visual that supports reasoning and communication.</p>
<p>This section focuses on simple but essential customization techniques that improve clarity and help ensure that visualizations convey the intended message.</p>
<hr>
<section id="why-customization-matters" class="level3">
<h3 class="anchored" data-anchor-id="why-customization-matters">4.1 Why customization matters</h3>
<p>Visualization works by mapping data to visual properties. If those properties are unclear or poorly chosen, interpretation suffers—even when the underlying data is sound.</p>
<p>Customization matters for two main reasons. First, it improves <strong>readability</strong>. Titles, labels, and legends help viewers understand what they are looking at without guessing. Second, it helps avoid <strong>misleading visuals</strong>. Poor choices in scale, labeling, or color can suggest patterns that are not actually present or hide patterns that are.</p>
<p>Uncustomized plots often rely on default settings that may not match the context of the data. Defaults are designed to work reasonably well in general, but they are not tailored to specific analytical questions. Customization allows the analyst to align the visual with intent.</p>
<hr>
</section>
<section id="titles-labels-and-legends" class="level3">
<h3 class="anchored" data-anchor-id="titles-labels-and-legends">4.2 Titles, labels, and legends</h3>
<p>Titles, axis labels, and legends provide essential context. Without them, viewers must infer meaning from the shape of the plot alone, which increases cognitive load and the risk of misinterpretation.</p>
<p>A <strong>title</strong> describes what the plot represents. It should be concise but informative, indicating what is being visualized and, when appropriate, under what conditions.</p>
<p><strong>Axis labels</strong> explain what each axis represents, including units when relevant. Clear labeling makes it easier to interpret magnitudes and compare values.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Example Plot"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"X"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Y"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When a plot includes multiple series or categories, a <strong>legend</strong> helps distinguish between them. Legends map visual elements, such as colors or markers, to their meanings.</p>
<p>Together, titles, labels, and legends are used to turn a plot from a visual pattern into an interpretable artifact. They make the assumptions and structure of the visualization explicit. As your knowledge in analytics grows, it becomes more and more important to use these tools. It is not uncommon to see experts with extremely poorly annotated visuals, because they know them so well!</p>
<hr>
</section>
<section id="colors-and-styles" class="level3">
<h3 class="anchored" data-anchor-id="colors-and-styles">4.3 Colors and styles</h3>
<p>Color is a powerful visual cue, but it must be used intentionally. Color choices can highlight differences, group related elements, or draw attention to specific features. At the same time, excessive or inconsistent use of color can create visual clutter and confusion.</p>
<p>Good color usage follows a few general principles:<br>
- Use color to encode information, not decoration.<br>
- Keep color palettes simple and consistent.<br>
- Avoid using too many colors at once.<br>
- Ensure sufficient contrast for readability.</p>
<p>Color can be problematic, if it is the only signal in a visualization. Imagine a chart with only red and green dots, the red dots are “bad” and the green dots are “good”. This chart would be entirely useless to someone who is color blind.</p>
<p>Consistency across plots is especially important in analytical workflows. When similar plots use similar styles, viewers can focus on the data rather than re-learning how to read each visualization.</p>
<p>Styles also include choices about markers, line thickness, and layout. These choices affect how easily patterns can be detected and compared. Small adjustments can significantly improve interpretability without adding complexity.</p>
<p>Customization is not about making plots look impressive. It is about making them <strong>honest, readable, and aligned with analytical intent</strong>. As visualizations become more central to reasoning and communication, thoughtful customization becomes a core analytical skill rather than a cosmetic one.</p>
</section>
</section>
<section id="seaborn-statistical-visualization-optional" class="level2">
<h2 class="anchored" data-anchor-id="seaborn-statistical-visualization-optional">5. Seaborn: Statistical Visualization <em>(Optional)</em></h2>
<p>Seaborn is a higher-level visualization library built on top of matplotlib. While matplotlib provides fine-grained control over plots, seaborn focuses on making <strong>statistical patterns</strong> easier to visualize with less code. This makes Seaborn very useful as a tool. It is faster and easier to create reasonable looking graphics and charts in Seaborn, but you don’t get the same level of fine tuned control you get in matplotlib. As LLM and coding tools get more powerful, I think we will see more shift towards the highly customizable graphing solutions, as the code to create it becomes easier/faster/cheaper to generate.</p>
<p>The core ideas of simulation and visualization do not depend on seaborn, but seaborn provides a useful preview of how visualization tools evolve toward higher-level abstractions.</p>
<hr>
<section id="why-seaborn-exists" class="level3">
<h3 class="anchored" data-anchor-id="why-seaborn-exists">5.1 Why seaborn exists</h3>
<p>Matplotlib is highly flexible, but that flexibility can require substantial setup when creating plots that emphasize statistical structure. Seaborn was designed to address this gap by providing functions that automatically apply common statistical conventions and aesthetically sensible defaults.</p>
<p>Seaborn builds on matplotlib rather than replacing it. When seaborn creates a plot, it is still using matplotlib underneath, but it handles many details, such as color palettes, axes formatting, and statistical aggregation, automatically.</p>
<p>The key distinction is focus: - <strong>Matplotlib</strong> emphasizes low-level control and general-purpose plotting. - <strong>Seaborn</strong> emphasizes statistical visualization and common analytical patterns.</p>
<p>Because of this focus, seaborn is often used for exploratory data analysis, where quickly understanding distributions, relationships, and group differences is more important than precise customization.</p>
<hr>
</section>
<section id="distribution-plots" class="level3">
<h3 class="anchored" data-anchor-id="distribution-plots">5.2 Distribution plots</h3>
<p>One of seaborn’s strengths is its support for <strong>distribution plots</strong>. Distribution plots visualize how values are spread across a range, making it easier to reason about variability, skewness, and concentration.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>sns.histplot(values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This example creates a histogram that shows the distribution of simulated values. Seaborn automatically selects binning, applies sensible styling, and labels the axes in a way that emphasizes the statistical meaning of the plot.</p>
<p>Distribution plots are useful for: - examining the shape of a variable, - comparing distributions across groups, - identifying skew, outliers, or unusual patterns.</p>
<p>Compared to basic matplotlib histograms, seaborn’s distribution plots reduce setup effort and encourage consistent visual conventions. This makes it easier to focus on interpretation rather than configuration.</p>
<p>Although seaborn is optional in this course, understanding why it exists reinforces a broader idea: as analytical tasks become more complex, tools evolve to capture common patterns and reduce repetitive work. Learning to recognize when higher-level tools are appropriate is part of developing analytical maturity.</p>
<hr>
</section>
</section>
<section id="integrated-workflow-from-data-to-visualization" class="level2">
<h2 class="anchored" data-anchor-id="integrated-workflow-from-data-to-visualization">6. Integrated Workflow: From Data to Visualization</h2>
<p>Up to this point, simulation and visualization have been introduced as individual skills. In practice, however, these activities are rarely isolated. Analytics workflows typically involve <strong>moving back and forth between data generation, summarization, and visualization</strong>, using each step to inform the next.</p>
<p>This section brings those pieces together into a single, integrated workflow. The emphasis is not on writing new code, but on understanding how analytical intent guides the sequence of steps from data to insight.</p>
<hr>
<section id="simulate-or-load-a-dataset" class="level3">
<h3 class="anchored" data-anchor-id="simulate-or-load-a-dataset">6.1 Simulate or load a dataset</h3>
<p>Every analysis begins with a dataset. That dataset may come from a real source, such as a cleaned CSV file from Week 3, or it may be generated synthetically through simulation. The choice depends on the goal of the analysis.</p>
<p>Simulation is often used when: - exploring hypothetical scenarios, - testing analysis logic, - or building intuition before working with real data.</p>
<p>Real datasets are used when: - answering specific empirical questions, - validating assumptions against observed behavior, - or producing results tied to real-world systems.</p>
<p>Regardless of origin, the key step is to <strong>establish analytical intent</strong>. Before summarizing or plotting, it should be clear what question the data is meant to support. This intent shapes every downstream decision, from which variables matter to which visualizations are appropriate.</p>
<p>At this stage, the dataset, simulated or loaded, becomes the shared object that connects all subsequent analysis.</p>
<hr>
</section>
<section id="summarize-before-visualizing" class="level3">
<h3 class="anchored" data-anchor-id="summarize-before-visualizing">6.2 Summarize before visualizing</h3>
<p>Visualization is most effective when it is informed by prior understanding of the data. Jumping directly to plotting without summarization can lead to confusion, misinterpretation, or unnecessary visual complexity.</p>
<p>Summaries provide essential context: - typical values, - variability and range, - presence of outliers, - and differences between variables.</p>
<p>These summaries help determine what kind of visualization makes sense. For example, understanding whether a variable is tightly clustered or widely dispersed influences choices about scale and plot type.</p>
<p>This step connects directly back to <strong>Week 3</strong>, where descriptive statistics were used to make sense of datasets before deeper analysis. Visualization builds on that foundation rather than replacing it.</p>
<p>Conceptually, summarization answers the question:<br>
<em>What should I expect to see before I look at a plot?</em></p>
<p>When visualizations align with prior summaries, confidence in interpretation increases. When they do not, it signals the need to revisit assumptions or investigate potential issues in the data.</p>
<hr>
</section>
<section id="visualize-insights" class="level3">
<h3 class="anchored" data-anchor-id="visualize-insights">6.3 Visualize insights</h3>
<p>With a clear dataset and informed expectations, visualization becomes a powerful tool for insight. At this stage, the goal is not to produce as many plots as possible, but to choose <strong>appropriate plot types</strong> that align with the analytical question.</p>
<p>Different questions call for different visuals: - trends and sequences suggest line plots, - category comparisons suggest bar plots, - relationships between variables suggest scatter plots, - distributions suggest histograms or density plots.</p>
<p>Choosing a plot type is a substantive analytical decision. It reflects assumptions about the data and about what patterns are meaningful. Once a plot is created, interpretation becomes the focus.</p>
<p>Interpreting visuals involves asking: - What patterns are visible? - Do these patterns align with expectations? - Are there anomalies or surprises? - What explanations are plausible given how the data was generated or collected?</p>
<p>In an integrated workflow, visualization does not mark the end of analysis. Instead, it often leads back to earlier steps. A surprising plot may prompt additional summarization, refined filtering, or even changes to the simulation process.</p>
<p>This iterative movement from <strong>data → summary → visualization → reasoning</strong>, is characteristic of real analytics and AI work. Understanding this cycle is more important than mastering any single plotting function.</p>
<hr>
</section>
</section>
<section id="mini-lab-raw-data-to-visual-insights" class="level2">
<h2 class="anchored" data-anchor-id="mini-lab-raw-data-to-visual-insights">7. Mini-Lab: Raw Data to Visual Insights</h2>
<p>This mini-lab brings together the key ideas from Week 4 into a single, end-to-end workflow. The objective is not to introduce new techniques, but to <strong>practice integrating simulation, summarization, and visualization</strong> in a way that mirrors real analytical work.</p>
<p>Rather than treating each step as isolated, this lab emphasizes how decisions made early in the process shape what can be learned later.</p>
<hr>
<section id="simulating-a-dataset" class="level3">
<h3 class="anchored" data-anchor-id="simulating-a-dataset">7.1 Simulating a dataset</h3>
<p>The workflow begins by generating a synthetic dataset. Simulation provides full control over how the data is created, which makes it easier to reason about expected patterns and variability.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> [random.random() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">200</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This simulated dataset represents a simple numeric variable. Although minimal, it is sufficient to explore distributional properties, variability, and visualization choices. In more complex scenarios, multiple simulated variables could be combined into a structured dataset.</p>
<p>At this stage, the goal is to establish a clear understanding of how the data was generated. Knowing the data-generating process makes later interpretation more grounded and less speculative.</p>
<hr>
</section>
<section id="cleaning-and-summarizing" class="level3">
<h3 class="anchored" data-anchor-id="cleaning-and-summarizing">7.2 Cleaning and summarizing</h3>
<p>Even simulated data benefits from inspection and summarization. Before visualizing, it is important to understand basic properties such as scale, range, and typical values.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>min_value <span class="op">=</span> <span class="bu">min</span>(values)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>max_value <span class="op">=</span> <span class="bu">max</span>(values)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>average <span class="op">=</span> <span class="bu">sum</span>(values) <span class="op">/</span> <span class="bu">len</span>(values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These summaries provide expectations for what the visualizations should reveal. For example, if values are uniformly distributed between 0 and 1, the average should be near the midpoint, and the range should reflect the bounds of the simulation.</p>
<p>This step mirrors the <strong>Week 3 workflow</strong>, where inspection and descriptive statistics preceded visualization. The same discipline applies here: visualization is most useful when informed by prior understanding.</p>
<hr>
</section>
<section id="visual-exploration" class="level3">
<h3 class="anchored" data-anchor-id="visual-exploration">7.3 Visual exploration</h3>
<p>With a summarized dataset, the next step is visual exploration. Visualization allows patterns to be assessed quickly and intuitively.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>plt.hist(values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This plot provides a visual representation of how values are distributed. Adjustments such as adding titles, labels, or changing bin counts can improve clarity and make interpretation easier.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Distribution of Simulated Values"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Value"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Frequency"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Creating multiple plots, such as line plots of cumulative values or comparisons across simulated groups, can further enrich understanding. The goal is not to generate as many plots as possible, but to create visuals that directly support reasoning about the data.</p>
<p>Refinement is part of the process. If a plot is confusing or uninformative, it should be adjusted or replaced. Visualization is iterative, not one-shot.</p>
<hr>
</section>
<section id="interpreting-visual-results" class="level3">
<h3 class="anchored" data-anchor-id="interpreting-visual-results">7.4 Interpreting visual results</h3>
<p>The final step is interpretation. Visualizations do not produce answers on their own; they require reasoning about what is shown and how it connects to the data-generating process.</p>
<p>Key questions to consider include: - Do the visual patterns align with how the data was simulated? - Are there unexpected features or anomalies? - How sensitive are the visuals to changes in sample size or plotting choices? - What additional questions does the visualization raise?</p>
<p>Because the data is synthetic, discrepancies between expectation and observation are especially informative. They may indicate randomness at work, limitations of small samples, or issues in how the visualization was constructed.</p>
<p>This mini-lab demonstrates a complete analytical cycle: generate data, summarize it, visualize it, and reason about the results. The same cycle will appear repeatedly in more advanced analytics and AI contexts, even as datasets and models become more complex.</p>
<hr>
</section>
</section>
<section id="week-4-summary" class="level2">
<h2 class="anchored" data-anchor-id="week-4-summary">Week 4 Summary</h2>
<p>This chapter introduced two closely related ideas: <strong>simulation</strong> as a way to generate data deliberately, and <strong>visualization</strong> as a way to reason about data effectively. Together, these skills support a shift from treating datasets as fixed artifacts to understanding them as the output of underlying processes that can be explored, tested, and interpreted.</p>
<p>Simulation was presented as a practical response to common limitations of real-world data. When data is incomplete, biased, restricted, or not yet available, synthetic data provides a controlled environment for experimentation. By using pseudo-random number generation, simulation makes uncertainty explicit and enables systematic “what if” exploration. The chapter emphasized that randomness in computation is not chaos, but <strong>controlled variability</strong>, a tool for understanding how outcomes can change across repeated realizations of the same process.</p>
<p>Visualization was framed as a reasoning tool rather than a presentation artifact. Visual representations reduce cognitive load and leverage human strengths in detecting patterns, trends, and anomalies. The chapter distinguished exploratory visualization from presentation visualization and highlighted visualization’s role as a diagnostic mechanism in analytics and AI workflows. Matplotlib provided a practical foundation for producing basic plots, while customization was treated as a substantive analytical responsibility, necessary for clarity, interpretability, and avoiding misleading impressions. An optional seaborn section introduced how higher-level visualization tools capture common statistical patterns and reduce repetitive plotting work.</p>
<p>The integrated workflow and mini-lab reinforced a complete analytical cycle: <strong>generate or obtain data → summarize → visualize → interpret → iterate</strong>. This cycle mirrors how real analytics work is performed and prepares the ground for the next stage of the course, where the focus will shift from describing and visualizing data to modeling it. By the end of Week 4, you should be able to generate synthetic data intentionally, visualize it thoughtfully, and interpret what you see in a way that reflects both the data-generating process and the analytical choices made along the way.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>